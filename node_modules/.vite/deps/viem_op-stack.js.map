{
  "version": 3,
  "sources": ["../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/buildDepositTransaction.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/buildInitiateWithdrawal.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/utils/getWithdrawalHashStorageSlot.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/buildProveWithdrawal.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/abis.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/estimateDepositTransactionGas.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/depositTransaction.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/estimateL1Fee.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/estimateContractL1Fee.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/estimateL1Gas.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/estimateContractL1Gas.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/estimateTotalFee.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/estimateContractTotalFee.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/estimateTotalGas.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/estimateContractTotalGas.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/getL1BaseFee.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/estimateFinalizeWithdrawalGas.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/finalizeWithdrawal.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/getL2Output.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/getTimeToFinalize.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/getTimeToNextL2Output.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/getTimeToProve.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/errors/withdrawal.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/utils/extractWithdrawalMessageLogs.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/utils/getWithdrawals.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/getWithdrawalStatus.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/estimateInitiateWithdrawalGas.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/initiateWithdrawal.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/estimateProveWithdrawalGas.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/proveWithdrawal.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/waitForNextL2Output.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/waitToFinalize.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/actions/waitToProve.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/decorators/publicL1.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/decorators/publicL2.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/decorators/walletL1.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/decorators/walletL2.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/parsers.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/utils/extractTransactionDepositedLogs.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/utils/opaqueDataToDepositData.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/utils/getSourceHash.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/utils/getL2TransactionHash.ts", "../../.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/chains/opStack/utils/getL2TransactionHashes.ts"],
  "sourcesContent": ["import type { Address } from 'abitype'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport {\n  type PrepareTransactionRequestErrorType,\n  type PrepareTransactionRequestParameters,\n  prepareTransactionRequest,\n} from '../../../actions/wallet/prepareTransactionRequest.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type {\n  Account,\n  DeriveAccount,\n  GetAccountParameter,\n} from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { Prettify, UnionOmit } from '../../../types/utils.js'\nimport type { DepositTransactionParameters } from './depositTransaction.js'\n\nexport type BuildDepositTransactionParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = GetAccountParameter<account, accountOverride, false> &\n  GetChainParameter<chain, chainOverride> & {\n    /** Gas limit for transaction execution on the L2. */\n    gas?: bigint\n    /** Value in wei to mint (deposit) on the L2. Debited from the caller's L1 balance. */\n    mint?: bigint\n    /** Value in wei sent with this transaction on the L2. Debited from the caller's L2 balance. */\n    value?: bigint\n  } & (\n    | {\n        /** Encoded contract method & arguments. */\n        data?: Hex\n        /** Whether or not this is a contract deployment transaction. */\n        isCreation?: false\n        /** L2 Transaction recipient. */\n        to?: Address\n      }\n    | {\n        /** Contract deployment bytecode. Required for contract deployment transactions. */\n        data: Hex\n        /** Whether or not this is a contract deployment transaction. */\n        isCreation: true\n        /** L2 Transaction recipient. Cannot exist for contract deployment transactions. */\n        to?: never\n      }\n  )\n\nexport type BuildDepositTransactionReturnType<\n  account extends Account | undefined = Account | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n> = Prettify<\n  UnionOmit<DepositTransactionParameters<Chain, account, Chain>, 'account'> & {\n    account: DeriveAccount<account, accountOverride>\n  }\n>\n\nexport type BuildDepositTransactionErrorType =\n  | ParseAccountErrorType\n  | PrepareTransactionRequestErrorType\n  | ErrorType\n\n/**\n * Prepares parameters for a [deposit transaction](https://github.com/ethereum-optimism/optimism/blob/develop/specs/deposits.md) to be initiated on an L1.\n *\n * - Docs: https://viem.sh/op-stack/actions/buildDepositTransaction\n *\n * @param client - Client to use\n * @param parameters - {@link BuildDepositTransactionParameters}\n * @returns Parameters for `depositTransaction`. {@link DepositTransactionReturnType}\n *\n * @example\n * import { createWalletClient, http, parseEther } from 'viem'\n * import { base } from 'viem/chains'\n * import { publicActionsL2 } from 'viem/op-stack'\n * import { buildDepositTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: base,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const args = await buildDepositTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function buildDepositTransaction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n  accountOverride extends Account | Address | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  args: BuildDepositTransactionParameters<\n    chain,\n    account,\n    chainOverride,\n    accountOverride\n  >,\n): Promise<BuildDepositTransactionReturnType<account, accountOverride>> {\n  const {\n    account: account_,\n    chain = client.chain,\n    gas,\n    data,\n    isCreation,\n    mint,\n    to,\n    value,\n  } = args\n\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const request = await prepareTransactionRequest(client, {\n    account: mint ? undefined : account,\n    chain,\n    gas,\n    data,\n    parameters: ['gas'],\n    to,\n    value,\n  } as PrepareTransactionRequestParameters)\n\n  return {\n    account,\n    request: {\n      data: request.data,\n      gas: request.gas,\n      mint,\n      isCreation,\n      to: request.to,\n      value: request.value,\n    },\n    targetChain: chain,\n  } as unknown as BuildDepositTransactionReturnType<account, accountOverride>\n}\n", "import type { Address } from 'abitype'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport {\n  type PrepareTransactionRequestErrorType,\n  type PrepareTransactionRequestParameters,\n  prepareTransactionRequest,\n} from '../../../actions/wallet/prepareTransactionRequest.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport type { Chain, GetChainParameter } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { Prettify, UnionOmit } from '../../../types/utils.js'\nimport type { InitiateWithdrawalParameters } from './initiateWithdrawal.js'\n\nexport type BuildInitiateWithdrawalParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n> = GetAccountParameter<account, accountOverride, false> &\n  GetChainParameter<chain, chainOverride> & {\n    /** Encoded contract method & arguments. */\n    data?: Hex\n    /** Gas limit for transaction execution on the L1. */\n    gas?: bigint\n    /** L1 Transaction recipient. */\n    to: Address\n    /** Value in wei to withdrawal to the L1. Debited from the caller's L2 balance. */\n    value?: bigint\n  }\n\nexport type BuildInitiateWithdrawalReturnType<\n  account extends Account | undefined = Account | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n> = Prettify<\n  UnionOmit<InitiateWithdrawalParameters<Chain, account, Chain>, 'account'> &\n    GetAccountParameter<account, accountOverride>\n>\n\nexport type BuildInitiateWithdrawalErrorType =\n  | ParseAccountErrorType\n  | PrepareTransactionRequestErrorType\n  | ErrorType\n\n/**\n * Prepares parameters for a [withdrawal](https://community.optimism.io/docs/protocol/withdrawal-flow/#withdrawal-initiating-transaction) from an L2 to the L1.\n *\n * - Docs: https://viem.sh/op-stack/actions/buildInitiateWithdrawal\n *\n * @param client - Client to use\n * @param parameters - {@link BuildInitiateWithdrawalParameters}\n * @returns Parameters for `depositTransaction`. {@link DepositTransactionReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { buildInitiateWithdrawal } from 'viem/wallet'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const args = await buildInitiateWithdrawal(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function buildInitiateWithdrawal<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n  accountOverride extends Account | Address | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  args: BuildInitiateWithdrawalParameters<\n    chain,\n    account,\n    chainOverride,\n    accountOverride\n  >,\n): Promise<BuildInitiateWithdrawalReturnType<account, accountOverride>> {\n  const { account: account_, chain = client.chain, gas, data, to, value } = args\n\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const request = await prepareTransactionRequest(client, {\n    account,\n    chain,\n    gas,\n    data,\n    parameters: ['gas'],\n    to,\n    value,\n  } as PrepareTransactionRequestParameters)\n\n  return {\n    account,\n    request: {\n      data: request.data,\n      gas: request.gas,\n      to: request.to,\n      value: request.value,\n    },\n  } as BuildInitiateWithdrawalReturnType<account, accountOverride>\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport type { Hash } from '../../../types/misc.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../../../utils/abi/encodeAbiParameters.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../../utils/hash/keccak256.js'\n\nexport type GetWithdrawalHashStorageSlotParameters = {\n  withdrawalHash: Hash\n}\nexport type GetWithdrawalHashStorageSlotReturnType = Hash\nexport type GetWithdrawalHashStorageSlotErrorType =\n  | EncodeAbiParametersErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nexport function getWithdrawalHashStorageSlot({\n  withdrawalHash,\n}: GetWithdrawalHashStorageSlotParameters) {\n  const data = encodeAbiParameters(\n    [{ type: 'bytes32' }, { type: 'uint256' }],\n    [withdrawalHash, 0n],\n  )\n  return keccak256(data)\n}\n", "import type { Address } from 'abitype'\nimport {\n  type GetBlockErrorType,\n  getBlock,\n} from '../../../actions/public/getBlock.js'\nimport {\n  type GetProofErrorType,\n  getProof,\n} from '../../../actions/public/getProof.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type {\n  Account,\n  DeriveAccount,\n  GetAccountParameter,\n} from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport { type Hex } from '../../../types/misc.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport { fromRlp } from '../../../utils/encoding/fromRlp.js'\nimport { toRlp } from '../../../utils/encoding/toRlp.js'\nimport { keccak256 } from '../../../utils/hash/keccak256.js'\nimport { contracts } from '../contracts.js'\nimport type { Withdrawal } from '../types/withdrawal.js'\nimport {\n  type GetWithdrawalHashStorageSlotErrorType,\n  getWithdrawalHashStorageSlot,\n} from '../utils/getWithdrawalHashStorageSlot.js'\nimport type { GetL2OutputReturnType } from './getL2Output.js'\nimport type { ProveWithdrawalParameters } from './proveWithdrawal.js'\n\nconst outputRootProofVersion =\n  '0x0000000000000000000000000000000000000000000000000000000000000000' as const\n\nexport type BuildProveWithdrawalParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = GetAccountParameter<account, accountOverride, false> &\n  GetChainParameter<chain, chainOverride> & {\n    withdrawal: Withdrawal\n    output: GetL2OutputReturnType\n  }\n\nexport type BuildProveWithdrawalReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n> = Prettify<\n  Pick<\n    ProveWithdrawalParameters,\n    'l2OutputIndex' | 'outputRootProof' | 'withdrawalProof' | 'withdrawal'\n  > & {\n    account: DeriveAccount<account, accountOverride>\n    targetChain: DeriveChain<chain, chainOverride>\n  }\n>\n\nexport type BuildProveWithdrawalErrorType =\n  | GetBlockErrorType\n  | GetProofErrorType\n  | GetWithdrawalHashStorageSlotErrorType\n  | ErrorType\n\n/**\n * Builds the transaction that proves a withdrawal was initiated on an L2. Used in the Withdrawal flow.\n *\n * - Docs: https://viem.sh/op-stack/actions/buildProveWithdrawal\n *\n * @param client - Client to use\n * @param parameters - {@link BuildProveWithdrawalParameters}\n * @returns The prove withdraw transaction request. {@link BuildProveWithdrawalReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { buildProveWithdrawal } from 'viem/op-stack'\n *\n * const publicClientL2 = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n *\n * const args = await buildProveWithdrawal(publicClientL2, {\n *   output: { ... },\n *   withdrawal: { ... },\n * })\n */\nexport async function buildProveWithdrawal<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n  accountOverride extends Account | Address | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  args: BuildProveWithdrawalParameters<\n    chain,\n    account,\n    chainOverride,\n    accountOverride\n  >,\n): Promise<\n  BuildProveWithdrawalReturnType<chain, account, chainOverride, accountOverride>\n> {\n  const { account, chain = client.chain, output, withdrawal } = args\n  const { withdrawalHash } = withdrawal\n  const { l2BlockNumber } = output\n\n  const slot = getWithdrawalHashStorageSlot({ withdrawalHash })\n  const [proof, block] = await Promise.all([\n    getProof(client, {\n      address: contracts.l2ToL1MessagePasser.address,\n      storageKeys: [slot],\n      blockNumber: l2BlockNumber,\n    }),\n    getBlock(client, {\n      blockNumber: l2BlockNumber,\n    }),\n  ])\n\n  return {\n    account,\n    l2OutputIndex: output.outputIndex,\n    outputRootProof: {\n      latestBlockhash: block.hash,\n      messagePasserStorageRoot: proof.storageHash,\n      stateRoot: block.stateRoot,\n      version: outputRootProofVersion,\n    },\n    targetChain: chain,\n    withdrawalProof: maybeAddProofNode(\n      keccak256(slot),\n      proof.storageProof[0].proof,\n    ),\n    withdrawal,\n  } as unknown as BuildProveWithdrawalReturnType<\n    chain,\n    account,\n    chainOverride,\n    accountOverride\n  >\n}\n\nexport function maybeAddProofNode(key: string, proof: readonly Hex[]) {\n  const lastProofRlp = proof[proof.length - 1]\n  const lastProof = fromRlp(lastProofRlp)\n  if (lastProof.length !== 17) return proof\n\n  const modifiedProof = [...proof]\n  for (const item of lastProof) {\n    // Find any nodes located inside of the branch node.\n    if (!Array.isArray(item)) continue\n    // Check if the key inside the node matches the key we're looking for. We remove the first\n    // two characters (0x) and then we remove one more character (the first nibble) since this\n    // is the identifier for the type of node we're looking at. In this case we don't actually\n    // care what type of node it is because a branch node would only ever be the final proof\n    // element if (1) it includes the leaf node we're looking for or (2) it stores the value\n    // within itself. If (1) then this logic will work, if (2) then this won't find anything\n    // and we won't append any proof elements, which is exactly what we would want.\n    const suffix = item[0].slice(3)\n    if (typeof suffix !== 'string' || !key.endsWith(suffix)) continue\n    modifiedProof.push(toRlp(item))\n  }\n  return modifiedProof\n}\n", "/**\n * ABI for the OP Stack [`GasPriceOracle` contract](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/GasPriceOracle.sol).\n * @see https://optimistic.etherscan.io/address/0x420000000000000000000000000000000000000f\n */\nexport const gasPriceOracleAbi = [\n  { inputs: [], stateMutability: 'nonpayable', type: 'constructor' },\n  {\n    inputs: [],\n    name: 'DECIMALS',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'baseFee',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'decimals',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'gasPrice',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes', name: '_data', type: 'bytes' }],\n    name: 'getL1Fee',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes', name: '_data', type: 'bytes' }],\n    name: 'getL1GasUsed',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'l1BaseFee',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'overhead',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'scalar',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'version',\n    outputs: [{ internalType: 'string', name: '', type: 'string' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const\n\nexport const l2OutputOracleAbi = [\n  {\n    inputs: [\n      { internalType: 'uint256', name: '_submissionInterval', type: 'uint256' },\n      { internalType: 'uint256', name: '_l2BlockTime', type: 'uint256' },\n      {\n        internalType: 'uint256',\n        name: '_startingBlockNumber',\n        type: 'uint256',\n      },\n      { internalType: 'uint256', name: '_startingTimestamp', type: 'uint256' },\n      { internalType: 'address', name: '_proposer', type: 'address' },\n      { internalType: 'address', name: '_challenger', type: 'address' },\n      {\n        internalType: 'uint256',\n        name: '_finalizationPeriodSeconds',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'constructor',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: false, internalType: 'uint8', name: 'version', type: 'uint8' },\n    ],\n    name: 'Initialized',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'outputRoot',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'l2OutputIndex',\n        type: 'uint256',\n      },\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'l2BlockNumber',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'l1Timestamp',\n        type: 'uint256',\n      },\n    ],\n    name: 'OutputProposed',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'prevNextOutputIndex',\n        type: 'uint256',\n      },\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'newNextOutputIndex',\n        type: 'uint256',\n      },\n    ],\n    name: 'OutputsDeleted',\n    type: 'event',\n  },\n  {\n    inputs: [],\n    name: 'CHALLENGER',\n    outputs: [{ internalType: 'address', name: '', type: 'address' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'FINALIZATION_PERIOD_SECONDS',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'L2_BLOCK_TIME',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'PROPOSER',\n    outputs: [{ internalType: 'address', name: '', type: 'address' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'SUBMISSION_INTERVAL',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: '_l2BlockNumber', type: 'uint256' },\n    ],\n    name: 'computeL2Timestamp',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: '_l2OutputIndex', type: 'uint256' },\n    ],\n    name: 'deleteL2Outputs',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: '_l2OutputIndex', type: 'uint256' },\n    ],\n    name: 'getL2Output',\n    outputs: [\n      {\n        components: [\n          { internalType: 'bytes32', name: 'outputRoot', type: 'bytes32' },\n          { internalType: 'uint128', name: 'timestamp', type: 'uint128' },\n          { internalType: 'uint128', name: 'l2BlockNumber', type: 'uint128' },\n        ],\n        internalType: 'struct Types.OutputProposal',\n        name: '',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: '_l2BlockNumber', type: 'uint256' },\n    ],\n    name: 'getL2OutputAfter',\n    outputs: [\n      {\n        components: [\n          { internalType: 'bytes32', name: 'outputRoot', type: 'bytes32' },\n          { internalType: 'uint128', name: 'timestamp', type: 'uint128' },\n          { internalType: 'uint128', name: 'l2BlockNumber', type: 'uint128' },\n        ],\n        internalType: 'struct Types.OutputProposal',\n        name: '',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: '_l2BlockNumber', type: 'uint256' },\n    ],\n    name: 'getL2OutputIndexAfter',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_startingBlockNumber',\n        type: 'uint256',\n      },\n      { internalType: 'uint256', name: '_startingTimestamp', type: 'uint256' },\n    ],\n    name: 'initialize',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'latestBlockNumber',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'latestOutputIndex',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'nextBlockNumber',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'nextOutputIndex',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'bytes32', name: '_outputRoot', type: 'bytes32' },\n      { internalType: 'uint256', name: '_l2BlockNumber', type: 'uint256' },\n      { internalType: 'bytes32', name: '_l1BlockHash', type: 'bytes32' },\n      { internalType: 'uint256', name: '_l1BlockNumber', type: 'uint256' },\n    ],\n    name: 'proposeL2Output',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'startingBlockNumber',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'startingTimestamp',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'version',\n    outputs: [{ internalType: 'string', name: '', type: 'string' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const\n\nexport const l1StandardBridgeAbi = [\n  { stateMutability: 'nonpayable', type: 'constructor', inputs: [] },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      {\n        name: 'localToken',\n        internalType: 'address',\n        type: 'address',\n        indexed: true,\n      },\n      {\n        name: 'remoteToken',\n        internalType: 'address',\n        type: 'address',\n        indexed: true,\n      },\n      { name: 'from', internalType: 'address', type: 'address', indexed: true },\n      { name: 'to', internalType: 'address', type: 'address', indexed: false },\n      {\n        name: 'amount',\n        internalType: 'uint256',\n        type: 'uint256',\n        indexed: false,\n      },\n      {\n        name: 'extraData',\n        internalType: 'bytes',\n        type: 'bytes',\n        indexed: false,\n      },\n    ],\n    name: 'ERC20BridgeFinalized',\n  },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      {\n        name: 'localToken',\n        internalType: 'address',\n        type: 'address',\n        indexed: true,\n      },\n      {\n        name: 'remoteToken',\n        internalType: 'address',\n        type: 'address',\n        indexed: true,\n      },\n      { name: 'from', internalType: 'address', type: 'address', indexed: true },\n      { name: 'to', internalType: 'address', type: 'address', indexed: false },\n      {\n        name: 'amount',\n        internalType: 'uint256',\n        type: 'uint256',\n        indexed: false,\n      },\n      {\n        name: 'extraData',\n        internalType: 'bytes',\n        type: 'bytes',\n        indexed: false,\n      },\n    ],\n    name: 'ERC20BridgeInitiated',\n  },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      {\n        name: 'l1Token',\n        internalType: 'address',\n        type: 'address',\n        indexed: true,\n      },\n      {\n        name: 'l2Token',\n        internalType: 'address',\n        type: 'address',\n        indexed: true,\n      },\n      { name: 'from', internalType: 'address', type: 'address', indexed: true },\n      { name: 'to', internalType: 'address', type: 'address', indexed: false },\n      {\n        name: 'amount',\n        internalType: 'uint256',\n        type: 'uint256',\n        indexed: false,\n      },\n      {\n        name: 'extraData',\n        internalType: 'bytes',\n        type: 'bytes',\n        indexed: false,\n      },\n    ],\n    name: 'ERC20DepositInitiated',\n  },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      {\n        name: 'l1Token',\n        internalType: 'address',\n        type: 'address',\n        indexed: true,\n      },\n      {\n        name: 'l2Token',\n        internalType: 'address',\n        type: 'address',\n        indexed: true,\n      },\n      { name: 'from', internalType: 'address', type: 'address', indexed: true },\n      { name: 'to', internalType: 'address', type: 'address', indexed: false },\n      {\n        name: 'amount',\n        internalType: 'uint256',\n        type: 'uint256',\n        indexed: false,\n      },\n      {\n        name: 'extraData',\n        internalType: 'bytes',\n        type: 'bytes',\n        indexed: false,\n      },\n    ],\n    name: 'ERC20WithdrawalFinalized',\n  },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      { name: 'from', internalType: 'address', type: 'address', indexed: true },\n      { name: 'to', internalType: 'address', type: 'address', indexed: true },\n      {\n        name: 'amount',\n        internalType: 'uint256',\n        type: 'uint256',\n        indexed: false,\n      },\n      {\n        name: 'extraData',\n        internalType: 'bytes',\n        type: 'bytes',\n        indexed: false,\n      },\n    ],\n    name: 'ETHBridgeFinalized',\n  },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      { name: 'from', internalType: 'address', type: 'address', indexed: true },\n      { name: 'to', internalType: 'address', type: 'address', indexed: true },\n      {\n        name: 'amount',\n        internalType: 'uint256',\n        type: 'uint256',\n        indexed: false,\n      },\n      {\n        name: 'extraData',\n        internalType: 'bytes',\n        type: 'bytes',\n        indexed: false,\n      },\n    ],\n    name: 'ETHBridgeInitiated',\n  },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      { name: 'from', internalType: 'address', type: 'address', indexed: true },\n      { name: 'to', internalType: 'address', type: 'address', indexed: true },\n      {\n        name: 'amount',\n        internalType: 'uint256',\n        type: 'uint256',\n        indexed: false,\n      },\n      {\n        name: 'extraData',\n        internalType: 'bytes',\n        type: 'bytes',\n        indexed: false,\n      },\n    ],\n    name: 'ETHDepositInitiated',\n  },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      { name: 'from', internalType: 'address', type: 'address', indexed: true },\n      { name: 'to', internalType: 'address', type: 'address', indexed: true },\n      {\n        name: 'amount',\n        internalType: 'uint256',\n        type: 'uint256',\n        indexed: false,\n      },\n      {\n        name: 'extraData',\n        internalType: 'bytes',\n        type: 'bytes',\n        indexed: false,\n      },\n    ],\n    name: 'ETHWithdrawalFinalized',\n  },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      { name: 'version', internalType: 'uint8', type: 'uint8', indexed: false },\n    ],\n    name: 'Initialized',\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'MESSENGER',\n    outputs: [\n      {\n        name: '',\n        internalType: 'contract CrossDomainMessenger',\n        type: 'address',\n      },\n    ],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'OTHER_BRIDGE',\n    outputs: [\n      { name: '', internalType: 'contract StandardBridge', type: 'address' },\n    ],\n  },\n  {\n    stateMutability: 'nonpayable',\n    type: 'function',\n    inputs: [\n      { name: '_localToken', internalType: 'address', type: 'address' },\n      { name: '_remoteToken', internalType: 'address', type: 'address' },\n      { name: '_amount', internalType: 'uint256', type: 'uint256' },\n      { name: '_minGasLimit', internalType: 'uint32', type: 'uint32' },\n      { name: '_extraData', internalType: 'bytes', type: 'bytes' },\n    ],\n    name: 'bridgeERC20',\n    outputs: [],\n  },\n  {\n    stateMutability: 'nonpayable',\n    type: 'function',\n    inputs: [\n      { name: '_localToken', internalType: 'address', type: 'address' },\n      { name: '_remoteToken', internalType: 'address', type: 'address' },\n      { name: '_to', internalType: 'address', type: 'address' },\n      { name: '_amount', internalType: 'uint256', type: 'uint256' },\n      { name: '_minGasLimit', internalType: 'uint32', type: 'uint32' },\n      { name: '_extraData', internalType: 'bytes', type: 'bytes' },\n    ],\n    name: 'bridgeERC20To',\n    outputs: [],\n  },\n  {\n    stateMutability: 'payable',\n    type: 'function',\n    inputs: [\n      { name: '_minGasLimit', internalType: 'uint32', type: 'uint32' },\n      { name: '_extraData', internalType: 'bytes', type: 'bytes' },\n    ],\n    name: 'bridgeETH',\n    outputs: [],\n  },\n  {\n    stateMutability: 'payable',\n    type: 'function',\n    inputs: [\n      { name: '_to', internalType: 'address', type: 'address' },\n      { name: '_minGasLimit', internalType: 'uint32', type: 'uint32' },\n      { name: '_extraData', internalType: 'bytes', type: 'bytes' },\n    ],\n    name: 'bridgeETHTo',\n    outputs: [],\n  },\n  {\n    stateMutability: 'nonpayable',\n    type: 'function',\n    inputs: [\n      { name: '_l1Token', internalType: 'address', type: 'address' },\n      { name: '_l2Token', internalType: 'address', type: 'address' },\n      { name: '_amount', internalType: 'uint256', type: 'uint256' },\n      { name: '_minGasLimit', internalType: 'uint32', type: 'uint32' },\n      { name: '_extraData', internalType: 'bytes', type: 'bytes' },\n    ],\n    name: 'depositERC20',\n    outputs: [],\n  },\n  {\n    stateMutability: 'nonpayable',\n    type: 'function',\n    inputs: [\n      { name: '_l1Token', internalType: 'address', type: 'address' },\n      { name: '_l2Token', internalType: 'address', type: 'address' },\n      { name: '_to', internalType: 'address', type: 'address' },\n      { name: '_amount', internalType: 'uint256', type: 'uint256' },\n      { name: '_minGasLimit', internalType: 'uint32', type: 'uint32' },\n      { name: '_extraData', internalType: 'bytes', type: 'bytes' },\n    ],\n    name: 'depositERC20To',\n    outputs: [],\n  },\n  {\n    stateMutability: 'payable',\n    type: 'function',\n    inputs: [\n      { name: '_minGasLimit', internalType: 'uint32', type: 'uint32' },\n      { name: '_extraData', internalType: 'bytes', type: 'bytes' },\n    ],\n    name: 'depositETH',\n    outputs: [],\n  },\n  {\n    stateMutability: 'payable',\n    type: 'function',\n    inputs: [\n      { name: '_to', internalType: 'address', type: 'address' },\n      { name: '_minGasLimit', internalType: 'uint32', type: 'uint32' },\n      { name: '_extraData', internalType: 'bytes', type: 'bytes' },\n    ],\n    name: 'depositETHTo',\n    outputs: [],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [\n      { name: '', internalType: 'address', type: 'address' },\n      { name: '', internalType: 'address', type: 'address' },\n    ],\n    name: 'deposits',\n    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],\n  },\n  {\n    stateMutability: 'nonpayable',\n    type: 'function',\n    inputs: [\n      { name: '_localToken', internalType: 'address', type: 'address' },\n      { name: '_remoteToken', internalType: 'address', type: 'address' },\n      { name: '_from', internalType: 'address', type: 'address' },\n      { name: '_to', internalType: 'address', type: 'address' },\n      { name: '_amount', internalType: 'uint256', type: 'uint256' },\n      { name: '_extraData', internalType: 'bytes', type: 'bytes' },\n    ],\n    name: 'finalizeBridgeERC20',\n    outputs: [],\n  },\n  {\n    stateMutability: 'payable',\n    type: 'function',\n    inputs: [\n      { name: '_from', internalType: 'address', type: 'address' },\n      { name: '_to', internalType: 'address', type: 'address' },\n      { name: '_amount', internalType: 'uint256', type: 'uint256' },\n      { name: '_extraData', internalType: 'bytes', type: 'bytes' },\n    ],\n    name: 'finalizeBridgeETH',\n    outputs: [],\n  },\n  {\n    stateMutability: 'nonpayable',\n    type: 'function',\n    inputs: [\n      { name: '_l1Token', internalType: 'address', type: 'address' },\n      { name: '_l2Token', internalType: 'address', type: 'address' },\n      { name: '_from', internalType: 'address', type: 'address' },\n      { name: '_to', internalType: 'address', type: 'address' },\n      { name: '_amount', internalType: 'uint256', type: 'uint256' },\n      { name: '_extraData', internalType: 'bytes', type: 'bytes' },\n    ],\n    name: 'finalizeERC20Withdrawal',\n    outputs: [],\n  },\n  {\n    stateMutability: 'payable',\n    type: 'function',\n    inputs: [\n      { name: '_from', internalType: 'address', type: 'address' },\n      { name: '_to', internalType: 'address', type: 'address' },\n      { name: '_amount', internalType: 'uint256', type: 'uint256' },\n      { name: '_extraData', internalType: 'bytes', type: 'bytes' },\n    ],\n    name: 'finalizeETHWithdrawal',\n    outputs: [],\n  },\n  {\n    stateMutability: 'nonpayable',\n    type: 'function',\n    inputs: [\n      {\n        name: '_messenger',\n        internalType: 'contract CrossDomainMessenger',\n        type: 'address',\n      },\n    ],\n    name: 'initialize',\n    outputs: [],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'l2TokenBridge',\n    outputs: [{ name: '', internalType: 'address', type: 'address' }],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'messenger',\n    outputs: [\n      {\n        name: '',\n        internalType: 'contract CrossDomainMessenger',\n        type: 'address',\n      },\n    ],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'otherBridge',\n    outputs: [\n      { name: '', internalType: 'contract StandardBridge', type: 'address' },\n    ],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'version',\n    outputs: [{ name: '', internalType: 'string', type: 'string' }],\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\nexport const l2ToL1MessagePasserAbi = [\n  { inputs: [], stateMutability: 'nonpayable', type: 'constructor' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'target',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'value',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'gasLimit',\n        type: 'uint256',\n      },\n      { indexed: false, internalType: 'bytes', name: 'data', type: 'bytes' },\n      {\n        indexed: false,\n        internalType: 'bytes32',\n        name: 'withdrawalHash',\n        type: 'bytes32',\n      },\n    ],\n    name: 'MessagePassed',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'WithdrawerBalanceBurnt',\n    type: 'event',\n  },\n  {\n    inputs: [],\n    name: 'MESSAGE_VERSION',\n    outputs: [{ internalType: 'uint16', name: '', type: 'uint16' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'burn',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: '_target', type: 'address' },\n      { internalType: 'uint256', name: '_gasLimit', type: 'uint256' },\n      { internalType: 'bytes', name: '_data', type: 'bytes' },\n    ],\n    name: 'initiateWithdrawal',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'messageNonce',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    name: 'sentMessages',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'version',\n    outputs: [{ internalType: 'string', name: '', type: 'string' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\nexport const portalAbi = [\n  { stateMutability: 'nonpayable', type: 'constructor', inputs: [] },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      { name: 'version', internalType: 'uint8', type: 'uint8', indexed: false },\n    ],\n    name: 'Initialized',\n  },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      {\n        name: 'account',\n        internalType: 'address',\n        type: 'address',\n        indexed: false,\n      },\n    ],\n    name: 'Paused',\n  },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      { name: 'from', internalType: 'address', type: 'address', indexed: true },\n      { name: 'to', internalType: 'address', type: 'address', indexed: true },\n      {\n        name: 'version',\n        internalType: 'uint256',\n        type: 'uint256',\n        indexed: true,\n      },\n      {\n        name: 'opaqueData',\n        internalType: 'bytes',\n        type: 'bytes',\n        indexed: false,\n      },\n    ],\n    name: 'TransactionDeposited',\n  },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      {\n        name: 'account',\n        internalType: 'address',\n        type: 'address',\n        indexed: false,\n      },\n    ],\n    name: 'Unpaused',\n  },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      {\n        name: 'withdrawalHash',\n        internalType: 'bytes32',\n        type: 'bytes32',\n        indexed: true,\n      },\n      { name: 'success', internalType: 'bool', type: 'bool', indexed: false },\n    ],\n    name: 'WithdrawalFinalized',\n  },\n  {\n    type: 'event',\n    anonymous: false,\n    inputs: [\n      {\n        name: 'withdrawalHash',\n        internalType: 'bytes32',\n        type: 'bytes32',\n        indexed: true,\n      },\n      { name: 'from', internalType: 'address', type: 'address', indexed: true },\n      { name: 'to', internalType: 'address', type: 'address', indexed: true },\n    ],\n    name: 'WithdrawalProven',\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'GUARDIAN',\n    outputs: [{ name: '', internalType: 'address', type: 'address' }],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'L2_ORACLE',\n    outputs: [\n      { name: '', internalType: 'contract L2OutputOracle', type: 'address' },\n    ],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'SYSTEM_CONFIG',\n    outputs: [\n      { name: '', internalType: 'contract SystemConfig', type: 'address' },\n    ],\n  },\n  {\n    stateMutability: 'payable',\n    type: 'function',\n    inputs: [\n      { name: '_to', internalType: 'address', type: 'address' },\n      { name: '_value', internalType: 'uint256', type: 'uint256' },\n      { name: '_gasLimit', internalType: 'uint64', type: 'uint64' },\n      { name: '_isCreation', internalType: 'bool', type: 'bool' },\n      { name: '_data', internalType: 'bytes', type: 'bytes' },\n    ],\n    name: 'depositTransaction',\n    outputs: [],\n  },\n  {\n    stateMutability: 'payable',\n    type: 'function',\n    inputs: [],\n    name: 'donateETH',\n    outputs: [],\n  },\n  {\n    stateMutability: 'nonpayable',\n    type: 'function',\n    inputs: [\n      {\n        name: '_tx',\n        internalType: 'struct Types.WithdrawalTransaction',\n        type: 'tuple',\n        components: [\n          { name: 'nonce', internalType: 'uint256', type: 'uint256' },\n          { name: 'sender', internalType: 'address', type: 'address' },\n          { name: 'target', internalType: 'address', type: 'address' },\n          { name: 'value', internalType: 'uint256', type: 'uint256' },\n          { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },\n          { name: 'data', internalType: 'bytes', type: 'bytes' },\n        ],\n      },\n    ],\n    name: 'finalizeWithdrawalTransaction',\n    outputs: [],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],\n    name: 'finalizedWithdrawals',\n    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'guardian',\n    outputs: [{ name: '', internalType: 'address', type: 'address' }],\n  },\n  {\n    stateMutability: 'nonpayable',\n    type: 'function',\n    inputs: [\n      {\n        name: '_l2Oracle',\n        internalType: 'contract L2OutputOracle',\n        type: 'address',\n      },\n      { name: '_guardian', internalType: 'address', type: 'address' },\n      {\n        name: '_systemConfig',\n        internalType: 'contract SystemConfig',\n        type: 'address',\n      },\n      { name: '_paused', internalType: 'bool', type: 'bool' },\n    ],\n    name: 'initialize',\n    outputs: [],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [\n      { name: '_l2OutputIndex', internalType: 'uint256', type: 'uint256' },\n    ],\n    name: 'isOutputFinalized',\n    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'l2Oracle',\n    outputs: [\n      { name: '', internalType: 'contract L2OutputOracle', type: 'address' },\n    ],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'l2Sender',\n    outputs: [{ name: '', internalType: 'address', type: 'address' }],\n  },\n  {\n    stateMutability: 'pure',\n    type: 'function',\n    inputs: [{ name: '_byteCount', internalType: 'uint64', type: 'uint64' }],\n    name: 'minimumGasLimit',\n    outputs: [{ name: '', internalType: 'uint64', type: 'uint64' }],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'params',\n    outputs: [\n      { name: 'prevBaseFee', internalType: 'uint128', type: 'uint128' },\n      { name: 'prevBoughtGas', internalType: 'uint64', type: 'uint64' },\n      { name: 'prevBlockNum', internalType: 'uint64', type: 'uint64' },\n    ],\n  },\n  {\n    stateMutability: 'nonpayable',\n    type: 'function',\n    inputs: [],\n    name: 'pause',\n    outputs: [],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'paused',\n    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],\n  },\n  {\n    stateMutability: 'nonpayable',\n    type: 'function',\n    inputs: [\n      {\n        name: '_tx',\n        internalType: 'struct Types.WithdrawalTransaction',\n        type: 'tuple',\n        components: [\n          { name: 'nonce', internalType: 'uint256', type: 'uint256' },\n          { name: 'sender', internalType: 'address', type: 'address' },\n          { name: 'target', internalType: 'address', type: 'address' },\n          { name: 'value', internalType: 'uint256', type: 'uint256' },\n          { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },\n          { name: 'data', internalType: 'bytes', type: 'bytes' },\n        ],\n      },\n      { name: '_l2OutputIndex', internalType: 'uint256', type: 'uint256' },\n      {\n        name: '_outputRootProof',\n        internalType: 'struct Types.OutputRootProof',\n        type: 'tuple',\n        components: [\n          { name: 'version', internalType: 'bytes32', type: 'bytes32' },\n          { name: 'stateRoot', internalType: 'bytes32', type: 'bytes32' },\n          {\n            name: 'messagePasserStorageRoot',\n            internalType: 'bytes32',\n            type: 'bytes32',\n          },\n          { name: 'latestBlockhash', internalType: 'bytes32', type: 'bytes32' },\n        ],\n      },\n      { name: '_withdrawalProof', internalType: 'bytes[]', type: 'bytes[]' },\n    ],\n    name: 'proveWithdrawalTransaction',\n    outputs: [],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],\n    name: 'provenWithdrawals',\n    outputs: [\n      { name: 'outputRoot', internalType: 'bytes32', type: 'bytes32' },\n      { name: 'timestamp', internalType: 'uint128', type: 'uint128' },\n      { name: 'l2OutputIndex', internalType: 'uint128', type: 'uint128' },\n    ],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'systemConfig',\n    outputs: [\n      { name: '', internalType: 'contract SystemConfig', type: 'address' },\n    ],\n  },\n  {\n    stateMutability: 'nonpayable',\n    type: 'function',\n    inputs: [],\n    name: 'unpause',\n    outputs: [],\n  },\n  {\n    stateMutability: 'view',\n    type: 'function',\n    inputs: [],\n    name: 'version',\n    outputs: [{ name: '', internalType: 'string', type: 'string' }],\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n", "import type { Address } from 'abitype'\nimport {\n  type EstimateContractGasErrorType,\n  type EstimateContractGasParameters,\n  estimateContractGas,\n} from '../../../actions/public/estimateContractGas.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { zeroAddress } from '../../../constants/address.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { UnionEvaluate, UnionOmit } from '../../../types/utils.js'\nimport type { FormattedTransactionRequest } from '../../../utils/formatters/transactionRequest.js'\nimport { portalAbi } from '../abis.js'\nimport type { GetContractAddressParameter } from '../types/contract.js'\nimport type { DepositRequest } from '../types/deposit.js'\n\nexport type EstimateDepositTransactionGasParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionEvaluate<\n  UnionOmit<\n    FormattedTransactionRequest<_derivedChain>,\n    | 'accessList'\n    | 'data'\n    | 'from'\n    | 'gas'\n    | 'gasPrice'\n    | 'to'\n    | 'type'\n    | 'value'\n  >\n> &\n  GetAccountParameter<account, Account | Address> &\n  GetChainParameter<chain, chainOverride> &\n  GetContractAddressParameter<_derivedChain, 'portal'> & {\n    /** L2 transaction request. */\n    request: DepositRequest\n    /** Gas limit for transaction execution on the L1. */\n    gas?: bigint | null\n  }\nexport type EstimateDepositTransactionGasReturnType = bigint\nexport type EstimateDepositTransactionGasErrorType =\n  | EstimateContractGasErrorType\n  | ErrorType\n\n/**\n * Estimates gas required to initiate a [deposit transaction](https://github.com/ethereum-optimism/optimism/blob/develop/specs/deposits.md) on an L1, which executes a transaction on L2.\n *\n * - Docs: https://viem.sh/op-stack/actions/estimateDepositTransactionGas\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateDepositTransactionGasParameters}\n * @returns The L1 transaction hash. {@link EstimateDepositTransactionGasReturnType}\n *\n * @example\n * import { createPublicClient, custom, parseEther } from 'viem'\n * import { base, mainnet } from 'viem/chains'\n * import { estimateDepositTransactionGas } from 'viem/op-stack'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const gas = await estimateDepositTransactionGas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   args: {\n *     gas: 21_000n,\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     value: parseEther('1'),\n *   },\n *   targetChain: base,\n * })\n */\nexport async function estimateDepositTransactionGas<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: EstimateDepositTransactionGasParameters<\n    chain,\n    account,\n    chainOverride\n  >,\n) {\n  const {\n    account,\n    chain = client.chain,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    request: {\n      data = '0x',\n      gas: l2Gas,\n      isCreation = false,\n      mint,\n      to = '0x',\n      value,\n    },\n    targetChain,\n  } = parameters\n\n  const portalAddress = (() => {\n    if (parameters.portalAddress) return parameters.portalAddress\n    if (chain) return targetChain!.contracts.portal[chain.id].address\n    return Object.values(targetChain!.contracts.portal)[0].address\n  })()\n\n  return estimateContractGas(client, {\n    account,\n    abi: portalAbi,\n    address: portalAddress,\n    chain,\n    functionName: 'depositTransaction',\n    args: [\n      isCreation ? zeroAddress : to,\n      value ?? mint ?? 0n,\n      l2Gas,\n      isCreation,\n      data,\n    ],\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    value: mint,\n  } as EstimateContractGasParameters)\n}\n", "import type { Address } from 'abitype'\nimport {\n  type WriteContractErrorType,\n  type WriteContractParameters,\n  writeContract,\n} from '../../../actions/wallet/writeContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { zeroAddress } from '../../../constants/address.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { UnionEvaluate, UnionOmit } from '../../../types/utils.js'\nimport type { FormattedTransactionRequest } from '../../../utils/formatters/transactionRequest.js'\nimport { portalAbi } from '../abis.js'\nimport type { GetContractAddressParameter } from '../types/contract.js'\nimport type { DepositRequest } from '../types/deposit.js'\nimport {\n  type EstimateDepositTransactionGasErrorType,\n  type EstimateDepositTransactionGasParameters,\n  estimateDepositTransactionGas,\n} from './estimateDepositTransactionGas.js'\n\nexport type DepositTransactionParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionEvaluate<\n  UnionOmit<\n    FormattedTransactionRequest<_derivedChain>,\n    | 'accessList'\n    | 'data'\n    | 'from'\n    | 'gas'\n    | 'gasPrice'\n    | 'to'\n    | 'type'\n    | 'value'\n  >\n> &\n  GetAccountParameter<account, Account | Address> &\n  GetChainParameter<chain, chainOverride> &\n  GetContractAddressParameter<_derivedChain, 'portal'> & {\n    /** L2 transaction request. */\n    request: DepositRequest\n    /**\n     * Gas limit for transaction execution on the L1.\n     * `null` to skip gas estimation & defer calculation to signer.\n     */\n    gas?: bigint | null\n  }\nexport type DepositTransactionReturnType = Hash\nexport type DepositTransactionErrorType =\n  | EstimateDepositTransactionGasErrorType\n  | WriteContractErrorType\n  | ErrorType\n\n/**\n * Initiates a [deposit transaction](https://github.com/ethereum-optimism/optimism/blob/develop/specs/deposits.md) on an L1, which executes a transaction on L2.\n *\n * Internally performs a contract write to the [`depositTransaction` function](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L1/OptimismPortal.sol#L378)\n * on the [Optimism Portal contract](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L1/OptimismPortal.sol).\n *\n * - Docs: https://viem.sh/op-stack/actions/depositTransaction\n *\n * @param client - Client to use\n * @param parameters - {@link DepositTransactionParameters}\n * @returns The L1 transaction hash. {@link DepositTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom, parseEther } from 'viem'\n * import { base, mainnet } from 'viem/chains'\n * import { depositTransaction } from 'viem/op-stack'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const hash = await depositTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   request: {\n *     gas: 21_000n,\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     value: parseEther('1'),\n *   },\n *   targetChain: base,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { base, mainnet } from 'viem/chains'\n * import { depositTransaction } from 'viem/op-stack'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const hash = await depositTransaction(client, {\n *   request: {\n *     gas: 21_000n,\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     value: parseEther('1'),\n *   },\n *   targetChain: base,\n * })\n */\nexport async function depositTransaction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: DepositTransactionParameters<chain, account, chainOverride>,\n) {\n  const {\n    account,\n    chain = client.chain,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    request: {\n      data = '0x',\n      gas: l2Gas,\n      isCreation = false,\n      mint,\n      to = '0x',\n      value,\n    },\n    targetChain,\n  } = parameters\n\n  const portalAddress = (() => {\n    if (parameters.portalAddress) return parameters.portalAddress\n    if (chain) return targetChain!.contracts.portal[chain.id].address\n    return Object.values(targetChain!.contracts.portal)[0].address\n  })()\n\n  const gas_ =\n    typeof gas !== 'number' && gas !== null\n      ? await estimateDepositTransactionGas(\n          client,\n          parameters as EstimateDepositTransactionGasParameters,\n        )\n      : undefined\n\n  return writeContract(client, {\n    account: account!,\n    abi: portalAbi,\n    address: portalAddress,\n    chain,\n    functionName: 'depositTransaction',\n    args: [\n      isCreation ? zeroAddress : to,\n      value ?? mint ?? 0n,\n      l2Gas,\n      isCreation,\n      data,\n    ],\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    value: mint,\n    gas: gas_,\n  } satisfies WriteContractParameters as any)\n}\n", "import type { Address } from 'abitype'\n\nimport {\n  type ReadContractErrorType,\n  readContract,\n} from '../../../actions/public/readContract.js'\nimport {\n  type PrepareTransactionRequestErrorType,\n  type PrepareTransactionRequestParameters,\n  prepareTransactionRequest,\n} from '../../../actions/wallet/prepareTransactionRequest.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport { type Chain, type GetChainParameter } from '../../../types/chain.js'\nimport type {\n  TransactionRequestEIP1559,\n  TransactionSerializable,\n} from '../../../types/transaction.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { getChainContractAddress } from '../../../utils/chain/getChainContractAddress.js'\nimport { type HexToNumberErrorType } from '../../../utils/encoding/fromHex.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../../utils/transaction/assertRequest.js'\nimport {\n  type SerializeTransactionErrorType,\n  serializeTransaction,\n} from '../../../utils/transaction/serializeTransaction.js'\nimport { gasPriceOracleAbi } from '../abis.js'\nimport { contracts } from '../contracts.js'\n\nexport type EstimateL1FeeParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n  TChainOverride extends Chain | undefined = undefined,\n> = Omit<TransactionRequestEIP1559, 'from'> &\n  GetAccountParameter<TAccount> &\n  GetChainParameter<TChain, TChainOverride> & {\n    /** Gas price oracle address. */\n    gasPriceOracleAddress?: Address\n  }\n\nexport type EstimateL1FeeReturnType = bigint\n\nexport type EstimateL1FeeErrorType =\n  | RequestErrorType\n  | PrepareTransactionRequestErrorType\n  | AssertRequestErrorType\n  | SerializeTransactionErrorType\n  | HexToNumberErrorType\n  | ReadContractErrorType\n  | ErrorType\n\n/**\n * Estimates the L1 data fee required to execute an L2 transaction.\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateL1FeeParameters}\n * @returns The fee (in wei). {@link EstimateL1FeeReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { estimateL1Fee } from 'viem/chains/optimism'\n *\n * const client = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n * const l1Fee = await estimateL1Fee(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function estimateL1Fee<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n  TChainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  args: EstimateL1FeeParameters<TChain, TAccount, TChainOverride>,\n): Promise<EstimateL1FeeReturnType> {\n  const {\n    chain = client.chain,\n    gasPriceOracleAddress: gasPriceOracleAddress_,\n  } = args\n\n  const gasPriceOracleAddress = (() => {\n    if (gasPriceOracleAddress_) return gasPriceOracleAddress_\n    if (chain)\n      return getChainContractAddress({\n        chain,\n        contract: 'gasPriceOracle',\n      })\n    return contracts.gasPriceOracle.address\n  })()\n\n  // Populate transaction with required fields to accurately estimate gas.\n  const request = await prepareTransactionRequest(\n    client,\n    args as PrepareTransactionRequestParameters,\n  )\n\n  assertRequest(request as AssertRequestParameters)\n\n  const transaction = serializeTransaction({\n    ...request,\n    type: 'eip1559',\n  } as TransactionSerializable)\n\n  return readContract(client, {\n    abi: gasPriceOracleAbi,\n    address: gasPriceOracleAddress,\n    functionName: 'getL1Fee',\n    args: [transaction as any],\n  })\n}\n", "import type { Abi } from 'abitype'\n\nimport type { Account } from '../../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  GetValue,\n} from '../../../types/contract.js'\nimport type { UnionOmit } from '../../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../../utils/errors/getContractError.js'\nimport {\n  type EstimateL1FeeErrorType,\n  type EstimateL1FeeParameters,\n  estimateL1Fee,\n} from './estimateL1Fee.js'\n\nexport type EstimateContractL1FeeParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n> = ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args\n> &\n  UnionOmit<\n    EstimateL1FeeParameters<chain, account, chainOverride>,\n    'data' | 'to' | 'value'\n  > &\n  GetValue<\n    abi,\n    functionName,\n    EstimateL1FeeParameters<\n      chain,\n      account,\n      chainOverride\n    > extends EstimateL1FeeParameters\n      ? EstimateL1FeeParameters<chain, account, chainOverride>['value']\n      : EstimateL1FeeParameters['value']\n  >\n\nexport type EstimateContractL1FeeReturnType = bigint\n\nexport type EstimateContractL1FeeErrorType = GetContractErrorReturnType<\n  EncodeFunctionDataErrorType | EstimateL1FeeErrorType | ParseAccountErrorType\n>\n\n/**\n * Estimates the L1 data fee required to execute an L2 contract write.\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateContractL1FeeParameters}\n * @returns The gas estimate (in wei). {@link EstimateContractL1FeeReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { estimateContractL1Fee } from 'viem/op-stack'\n *\n * const client = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n * const l1Fee = await estimateContractL1Fee(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint() public']),\n *   functionName: 'mint',\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * })\n */\nexport async function estimateContractL1Fee<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: EstimateContractL1FeeParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride\n  >,\n): Promise<EstimateContractL1FeeReturnType> {\n  const { abi, address, args, functionName, ...request } =\n    parameters as EstimateContractL1FeeParameters\n  const data = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as EncodeFunctionDataParameters)\n  try {\n    const fee = await estimateL1Fee(client, {\n      data,\n      to: address,\n      ...request,\n    } as unknown as EstimateL1FeeParameters)\n    return fee\n  } catch (error) {\n    const account = request.account ? parseAccount(request.account) : undefined\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/chains/op-stack/estimateContractL1Fee',\n      functionName,\n      sender: account?.address,\n    })\n  }\n}\n", "import type { Address } from 'abitype'\n\nimport {\n  type ReadContractErrorType,\n  readContract,\n} from '../../../actions/public/readContract.js'\nimport {\n  type PrepareTransactionRequestErrorType,\n  type PrepareTransactionRequestParameters,\n  prepareTransactionRequest,\n} from '../../../actions/wallet/prepareTransactionRequest.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport { type Chain, type GetChainParameter } from '../../../types/chain.js'\nimport type {\n  TransactionRequestEIP1559,\n  TransactionSerializable,\n} from '../../../types/transaction.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { getChainContractAddress } from '../../../utils/chain/getChainContractAddress.js'\nimport { type HexToNumberErrorType } from '../../../utils/encoding/fromHex.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../../utils/transaction/assertRequest.js'\nimport {\n  type SerializeTransactionErrorType,\n  serializeTransaction,\n} from '../../../utils/transaction/serializeTransaction.js'\nimport { gasPriceOracleAbi } from '../abis.js'\nimport { contracts } from '../contracts.js'\n\nexport type EstimateL1GasParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n  TChainOverride extends Chain | undefined = Chain | undefined,\n> = Omit<TransactionRequestEIP1559, 'from'> &\n  GetAccountParameter<TAccount> &\n  GetChainParameter<TChain, TChainOverride> & {\n    /** Gas price oracle address. */\n    gasPriceOracleAddress?: Address\n  }\n\nexport type EstimateL1GasReturnType = bigint\n\nexport type EstimateL1GasErrorType =\n  | RequestErrorType\n  | PrepareTransactionRequestErrorType\n  | AssertRequestErrorType\n  | SerializeTransactionErrorType\n  | HexToNumberErrorType\n  | ReadContractErrorType\n  | ErrorType\n\n/**\n * Estimates the L1 data gas required to execute an L2 transaction.\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateL1GasParameters}\n * @returns The gas estimate. {@link EstimateL1GasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { estimateL1Gas } from 'viem/chains/optimism'\n *\n * const client = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n * const l1Gas = await estimateL1Gas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function estimateL1Gas<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n  TChainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  args: EstimateL1GasParameters<TChain, TAccount, TChainOverride>,\n): Promise<EstimateL1GasReturnType> {\n  const {\n    chain = client.chain,\n    gasPriceOracleAddress: gasPriceOracleAddress_,\n  } = args\n\n  const gasPriceOracleAddress = (() => {\n    if (gasPriceOracleAddress_) return gasPriceOracleAddress_\n    if (chain)\n      return getChainContractAddress({\n        chain,\n        contract: 'gasPriceOracle',\n      })\n    return contracts.gasPriceOracle.address\n  })()\n\n  // Populate transaction with required fields to accurately estimate gas.\n  const request = await prepareTransactionRequest(\n    client,\n    args as PrepareTransactionRequestParameters,\n  )\n\n  assertRequest(request as AssertRequestParameters)\n\n  const transaction = serializeTransaction({\n    ...request,\n    type: 'eip1559',\n  } as TransactionSerializable)\n\n  return readContract(client, {\n    abi: gasPriceOracleAbi,\n    address: gasPriceOracleAddress,\n    functionName: 'getL1GasUsed',\n    args: [transaction as any],\n  })\n}\n", "import type { Abi } from 'abitype'\n\nimport type { Account } from '../../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  GetValue,\n} from '../../../types/contract.js'\nimport type { UnionOmit } from '../../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../../utils/errors/getContractError.js'\nimport {\n  type EstimateL1GasErrorType,\n  type EstimateL1GasParameters,\n  estimateL1Gas,\n} from './estimateL1Gas.js'\n\nexport type EstimateContractL1GasParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n> = ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args\n> &\n  UnionOmit<\n    EstimateL1GasParameters<chain, account, chainOverride>,\n    'data' | 'to' | 'value'\n  > &\n  GetValue<\n    abi,\n    functionName,\n    EstimateL1GasParameters<\n      chain,\n      account,\n      chainOverride\n    > extends EstimateL1GasParameters\n      ? EstimateL1GasParameters<chain, account, chainOverride>['value']\n      : EstimateL1GasParameters['value']\n  >\n\nexport type EstimateContractL1GasReturnType = bigint\n\nexport type EstimateContractL1GasErrorType = GetContractErrorReturnType<\n  EncodeFunctionDataErrorType | EstimateL1GasErrorType | ParseAccountErrorType\n>\n\n/**\n * Estimates the L1 data gas required to successfully execute a contract write function call.\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateContractL1GasParameters}\n * @returns The gas estimate (in wei). {@link EstimateContractL1GasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { estimateContractL1Gas } from 'viem/op-stack'\n *\n * const client = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n * const l1Gas = await estimateContractL1Gas(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint() public']),\n *   functionName: 'mint',\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * })\n */\nexport async function estimateContractL1Gas<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: EstimateContractL1GasParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride\n  >,\n): Promise<EstimateContractL1GasReturnType> {\n  const { abi, address, args, functionName, ...request } =\n    parameters as EstimateContractL1GasParameters\n  const data = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as EncodeFunctionDataParameters)\n  try {\n    const gas = await estimateL1Gas(client, {\n      data,\n      to: address,\n      ...request,\n    } as unknown as EstimateL1GasParameters)\n    return gas\n  } catch (error) {\n    const account = request.account ? parseAccount(request.account) : undefined\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/chains/op-stack/estimateContractL1Gas',\n      functionName,\n      sender: account?.address,\n    })\n  }\n}\n", "import {\n  type EstimateGasErrorType,\n  type EstimateGasParameters,\n  estimateGas,\n} from '../../../actions/public/estimateGas.js'\nimport {\n  type GetGasPriceErrorType,\n  getGasPrice,\n} from '../../../actions/public/getGasPrice.js'\nimport {\n  type PrepareTransactionRequestErrorType,\n  type PrepareTransactionRequestParameters,\n  prepareTransactionRequest,\n} from '../../../actions/wallet/prepareTransactionRequest.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account } from '../../../types/account.js'\nimport { type Chain } from '../../../types/chain.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport {\n  type EstimateL1FeeErrorType,\n  type EstimateL1FeeParameters,\n  estimateL1Fee,\n} from './estimateL1Fee.js'\n\nexport type EstimateTotalFeeParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n  TChainOverride extends Chain | undefined = Chain | undefined,\n> = EstimateL1FeeParameters<TChain, TAccount, TChainOverride>\n\nexport type EstimateTotalFeeReturnType = bigint\n\nexport type EstimateTotalFeeErrorType =\n  | RequestErrorType\n  | PrepareTransactionRequestErrorType\n  | EstimateL1FeeErrorType\n  | EstimateGasErrorType\n  | GetGasPriceErrorType\n  | ErrorType\n\n/**\n * Estimates the L1 data fee + L2 fee to execute an L2 transaction.\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateTotalFeeParameters}\n * @returns The fee (in wei). {@link EstimateTotalFeeReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { estimateTotalFee } from 'viem/chains/optimism'\n *\n * const client = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n * const totalGas = await estimateTotalFee(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function estimateTotalFee<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n  TChainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  args: EstimateTotalFeeParameters<TChain, TAccount, TChainOverride>,\n): Promise<EstimateTotalFeeReturnType> {\n  // Populate transaction with required fields to accurately estimate gas.\n  const request = await prepareTransactionRequest(\n    client,\n    args as PrepareTransactionRequestParameters,\n  )\n\n  const [l1Fee, l2Gas, l2GasPrice] = await Promise.all([\n    estimateL1Fee(client, request as EstimateL1FeeParameters),\n    estimateGas(client, request as EstimateGasParameters),\n    getGasPrice(client),\n  ])\n\n  return l1Fee + l2Gas * l2GasPrice\n}\n", "import type { Abi } from 'abitype'\n\nimport type { Account } from '../../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  GetValue,\n} from '../../../types/contract.js'\nimport type { UnionOmit } from '../../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../../utils/errors/getContractError.js'\nimport {\n  type EstimateTotalFeeErrorType,\n  type EstimateTotalFeeParameters,\n  estimateTotalFee,\n} from './estimateTotalFee.js'\n\nexport type EstimateContractTotalFeeParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n> = ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args\n> &\n  UnionOmit<\n    EstimateTotalFeeParameters<chain, account, chainOverride>,\n    'data' | 'to' | 'value'\n  > &\n  GetValue<\n    abi,\n    functionName,\n    EstimateTotalFeeParameters<\n      chain,\n      account,\n      chainOverride\n    > extends EstimateTotalFeeParameters\n      ? EstimateTotalFeeParameters<chain, account, chainOverride>['value']\n      : EstimateTotalFeeParameters['value']\n  >\n\nexport type EstimateContractTotalFeeReturnType = bigint\n\nexport type EstimateContractTotalFeeErrorType = GetContractErrorReturnType<\n  | EncodeFunctionDataErrorType\n  | EstimateTotalFeeErrorType\n  | ParseAccountErrorType\n>\n\n/**\n * Estimates the L1 data fee + L2 fee to execute an L2 contract write.\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateContractTotalFeeParameters}\n * @returns The gas estimate (in wei). {@link EstimateContractTotalFeeReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { estimateContractTotalFee } from 'viem/op-stack'\n *\n * const client = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n * const totalFee = await estimateContractTotalFee(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint() public']),\n *   functionName: 'mint',\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * })\n */\nexport async function estimateContractTotalFee<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: EstimateContractTotalFeeParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride\n  >,\n): Promise<EstimateContractTotalFeeReturnType> {\n  const { abi, address, args, functionName, ...request } =\n    parameters as EstimateContractTotalFeeParameters\n  const data = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as EncodeFunctionDataParameters)\n  try {\n    const fee = await estimateTotalFee(client, {\n      data,\n      to: address,\n      ...request,\n    } as unknown as EstimateTotalFeeParameters)\n    return fee\n  } catch (error) {\n    const account = request.account ? parseAccount(request.account) : undefined\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/chains/op-stack/estimateTotalFee',\n      functionName,\n      sender: account?.address,\n    })\n  }\n}\n", "import {\n  type EstimateGasErrorType,\n  type EstimateGasParameters,\n  estimateGas,\n} from '../../../actions/public/estimateGas.js'\nimport {\n  type PrepareTransactionRequestErrorType,\n  type PrepareTransactionRequestParameters,\n  prepareTransactionRequest,\n} from '../../../actions/wallet/prepareTransactionRequest.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account } from '../../../types/account.js'\nimport { type Chain } from '../../../types/chain.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport {\n  type EstimateL1GasErrorType,\n  type EstimateL1GasParameters,\n  estimateL1Gas,\n} from './estimateL1Gas.js'\n\nexport type EstimateTotalGasParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n  TChainOverride extends Chain | undefined = Chain | undefined,\n> = EstimateL1GasParameters<TChain, TAccount, TChainOverride>\n\nexport type EstimateTotalGasReturnType = bigint\n\nexport type EstimateTotalGasErrorType =\n  | RequestErrorType\n  | PrepareTransactionRequestErrorType\n  | EstimateL1GasErrorType\n  | EstimateGasErrorType\n  | ErrorType\n\n/**\n * Estimates the amount of L1 data gas + L2 gas required to execute an L2 transaction.\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateTotalGasParameters}\n * @returns The gas estimate. {@link EstimateTotalGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { estimateTotalGas } from 'viem/chains/optimism'\n *\n * const client = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n * const totalGas = await estimateTotalGas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function estimateTotalGas<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n  TChainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  args: EstimateTotalGasParameters<TChain, TAccount, TChainOverride>,\n): Promise<EstimateTotalGasReturnType> {\n  // Populate transaction with required fields to accurately estimate gas.\n  const request = await prepareTransactionRequest(\n    client,\n    args as PrepareTransactionRequestParameters,\n  )\n\n  const [l1Gas, l2Gas] = await Promise.all([\n    estimateL1Gas(client, request as EstimateL1GasParameters),\n    estimateGas(client, request as EstimateGasParameters),\n  ])\n\n  return l1Gas + l2Gas\n}\n", "import type { Abi } from 'abitype'\n\nimport type { Account } from '../../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  GetValue,\n} from '../../../types/contract.js'\nimport type { UnionOmit } from '../../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../../utils/errors/getContractError.js'\nimport {\n  type EstimateTotalGasErrorType,\n  type EstimateTotalGasParameters,\n  estimateTotalGas,\n} from './estimateTotalGas.js'\n\nexport type EstimateContractTotalGasParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n> = ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args\n> &\n  UnionOmit<\n    EstimateTotalGasParameters<chain, account, chainOverride>,\n    'data' | 'to' | 'value'\n  > &\n  GetValue<\n    abi,\n    functionName,\n    EstimateTotalGasParameters<\n      chain,\n      account,\n      chainOverride\n    > extends EstimateTotalGasParameters\n      ? EstimateTotalGasParameters<chain, account, chainOverride>['value']\n      : EstimateTotalGasParameters['value']\n  >\n\nexport type EstimateContractTotalGasReturnType = bigint\n\nexport type EstimateContractTotalGasErrorType = GetContractErrorReturnType<\n  | EncodeFunctionDataErrorType\n  | EstimateTotalGasErrorType\n  | ParseAccountErrorType\n>\n\n/**\n * Estimates the L1 data gas + L2 gas required to successfully execute a contract write function call.\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateContractTotalGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateContractTotalGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { estimateContractTotalGas } from 'viem/op-stack'\n *\n * const client = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n * const totalGas = await estimateContractTotalGas(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint() public']),\n *   functionName: 'mint',\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * })\n */\nexport async function estimateContractTotalGas<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: EstimateContractTotalGasParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride\n  >,\n): Promise<EstimateContractTotalGasReturnType> {\n  const { abi, address, args, functionName, ...request } =\n    parameters as EstimateContractTotalGasParameters\n  const data = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as EncodeFunctionDataParameters)\n  try {\n    const gas = await estimateTotalGas(client, {\n      data,\n      to: address,\n      ...request,\n    } as unknown as EstimateTotalGasParameters)\n    return gas\n  } catch (error) {\n    const account = request.account ? parseAccount(request.account) : undefined\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/chains/op-stack/estimateTotalGas',\n      functionName,\n      sender: account?.address,\n    })\n  }\n}\n", "import type { Address } from 'abitype'\n\nimport {\n  type ReadContractErrorType,\n  readContract,\n} from '../../../actions/public/readContract.js'\nimport { type PrepareTransactionRequestErrorType } from '../../../actions/wallet/prepareTransactionRequest.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport { type Chain, type GetChainParameter } from '../../../types/chain.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { getChainContractAddress } from '../../../utils/chain/getChainContractAddress.js'\nimport { type HexToNumberErrorType } from '../../../utils/encoding/fromHex.js'\n\nimport { gasPriceOracleAbi } from '../abis.js'\nimport { contracts } from '../contracts.js'\n\nexport type GetL1BaseFeeParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n  TChainOverride extends Chain | undefined = undefined,\n> = GetChainParameter<TChain, TChainOverride> & {\n  /** Gas price oracle address. */\n  gasPriceOracleAddress?: Address\n}\n\nexport type GetL1BaseFeeReturnType = bigint\n\nexport type GetL1BaseFeeErrorType =\n  | RequestErrorType\n  | PrepareTransactionRequestErrorType\n  | HexToNumberErrorType\n  | ReadContractErrorType\n  | ErrorType\n\n/**\n * get the L1 base fee\n *\n * @param client - Client to use\n * @param parameters - {@link GetL1BaseFeeParameters}\n * @returns The basefee (in wei). {@link GetL1BaseFeeReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { getL1BaseFee } from 'viem/chains/optimism'\n *\n * const client = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n * const l1BaseFee = await getL1BaseFee(client)\n */\nexport async function getL1BaseFee<\n  TChain extends Chain | undefined,\n  TChainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, TChain>,\n  args?: GetL1BaseFeeParameters<TChain, TChainOverride>,\n): Promise<GetL1BaseFeeReturnType> {\n  const {\n    chain = client.chain,\n    gasPriceOracleAddress: gasPriceOracleAddress_,\n  } = args || {}\n\n  const gasPriceOracleAddress = (() => {\n    if (gasPriceOracleAddress_) return gasPriceOracleAddress_\n    if (chain)\n      return getChainContractAddress({\n        chain,\n        contract: 'gasPriceOracle',\n      })\n    return contracts.gasPriceOracle.address\n  })()\n\n  return readContract(client, {\n    abi: gasPriceOracleAbi,\n    address: gasPriceOracleAddress,\n    functionName: 'l1BaseFee',\n  })\n}\n", "import type { Address } from 'abitype'\nimport {\n  type EstimateContractGasErrorType,\n  type EstimateContractGasParameters,\n  estimateContractGas,\n} from '../../../actions/public/estimateContractGas.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { UnionEvaluate, UnionOmit } from '../../../types/utils.js'\nimport type { FormattedTransactionRequest } from '../../../utils/formatters/transactionRequest.js'\nimport { portalAbi } from '../abis.js'\nimport type { GetContractAddressParameter } from '../types/contract.js'\nimport type { Withdrawal } from '../types/withdrawal.js'\n\nexport type EstimateFinalizeWithdrawalGasParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionEvaluate<\n  UnionOmit<\n    FormattedTransactionRequest<_derivedChain>,\n    | 'accessList'\n    | 'data'\n    | 'from'\n    | 'gas'\n    | 'gasPrice'\n    | 'to'\n    | 'type'\n    | 'value'\n  >\n> &\n  GetAccountParameter<account, Account | Address> &\n  GetChainParameter<chain, chainOverride> &\n  GetContractAddressParameter<_derivedChain, 'portal'> & {\n    /** Gas limit for transaction execution on the L2. */\n    gas?: bigint | null\n    withdrawal: Withdrawal\n  }\nexport type EstimateFinalizeWithdrawalGasReturnType = bigint\nexport type EstimateFinalizeWithdrawalGasErrorType =\n  | EstimateContractGasErrorType\n  | ErrorType\n\n/**\n * Estimates gas required to finalize a withdrawal that occurred on an L2.\n *\n * - Docs: https://viem.sh/op-stack/actions/estimateFinalizeWithdrawalGas\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateFinalizeWithdrawalGasParameters}\n * @returns Estimated gas. {@link EstimateFinalizeWithdrawalGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { base, mainnet } from 'viem/chains'\n * import { estimateFinalizeWithdrawalGas } from 'viem/op-stack'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const gas = await estimateFinalizeWithdrawalGas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   targetChain: optimism,\n *   withdrawal: { ... },\n * })\n */\nexport async function estimateFinalizeWithdrawalGas<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: EstimateFinalizeWithdrawalGasParameters<\n    chain,\n    account,\n    chainOverride\n  >,\n) {\n  const {\n    account,\n    chain = client.chain,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    targetChain,\n    withdrawal,\n  } = parameters\n\n  const portalAddress = (() => {\n    if (parameters.portalAddress) return parameters.portalAddress\n    if (chain) return targetChain!.contracts.portal[chain.id].address\n    return Object.values(targetChain!.contracts.portal)[0].address\n  })()\n\n  return estimateContractGas(client, {\n    account,\n    abi: portalAbi,\n    address: portalAddress,\n    chain,\n    functionName: 'finalizeWithdrawalTransaction',\n    args: [withdrawal],\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n  } as EstimateContractGasParameters)\n}\n", "import type { Address } from 'abitype'\nimport {\n  type WriteContractErrorType,\n  type WriteContractParameters,\n  writeContract,\n} from '../../../actions/wallet/writeContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { UnionEvaluate, UnionOmit } from '../../../types/utils.js'\nimport type { FormattedTransactionRequest } from '../../../utils/formatters/transactionRequest.js'\nimport { portalAbi } from '../abis.js'\nimport type { GetContractAddressParameter } from '../types/contract.js'\nimport type { Withdrawal } from '../types/withdrawal.js'\nimport {\n  type EstimateFinalizeWithdrawalGasErrorType,\n  type EstimateFinalizeWithdrawalGasParameters,\n  estimateFinalizeWithdrawalGas,\n} from './estimateFinalizeWithdrawalGas.js'\n\nexport type FinalizeWithdrawalParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionEvaluate<\n  UnionOmit<\n    FormattedTransactionRequest<_derivedChain>,\n    | 'accessList'\n    | 'data'\n    | 'from'\n    | 'gas'\n    | 'gasPrice'\n    | 'to'\n    | 'type'\n    | 'value'\n  >\n> &\n  GetAccountParameter<account, Account | Address> &\n  GetChainParameter<chain, chainOverride> &\n  GetContractAddressParameter<_derivedChain, 'portal'> & {\n    /**\n     * Gas limit for transaction execution on the L1.\n     * `null` to skip gas estimation & defer calculation to signer.\n     */\n    gas?: bigint | null\n    withdrawal: Withdrawal\n  }\nexport type FinalizeWithdrawalReturnType = Hash\nexport type FinalizeWithdrawalErrorType =\n  | EstimateFinalizeWithdrawalGasErrorType\n  | WriteContractErrorType\n  | ErrorType\n\n/**\n * Finalizes a withdrawal that occurred on an L2. Used in the Withdrawal flow.\n *\n * - Docs: https://viem.sh/op-stack/actions/finalizeWithdrawal\n *\n * @param client - Client to use\n * @param parameters - {@link FinalizeWithdrawalParameters}\n * @returns The finalize transaction hash. {@link FinalizeWithdrawalReturnType}\n *\n * @example\n * import { createWalletClient, http } from 'viem'\n * import { mainnet, optimism } from 'viem/chains'\n * import { finalizeWithdrawal } from 'viem/op-stack'\n *\n * const walletClientL1 = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const request = await finalizeWithdrawal(walletClientL1, {\n *   targetChain: optimism,\n *   withdrawal: { ... },\n * })\n */\nexport async function finalizeWithdrawal<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: FinalizeWithdrawalParameters<chain, account, chainOverride>,\n): Promise<FinalizeWithdrawalReturnType> {\n  const {\n    account,\n    chain = client.chain,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    targetChain,\n    withdrawal,\n  } = parameters\n\n  const portalAddress = (() => {\n    if (parameters.portalAddress) return parameters.portalAddress\n    if (chain) return targetChain!.contracts.portal[chain.id].address\n    return Object.values(targetChain!.contracts.portal)[0].address\n  })()\n\n  const gas_ =\n    typeof gas !== 'number' && gas !== null\n      ? await estimateFinalizeWithdrawalGas(\n          client,\n          parameters as EstimateFinalizeWithdrawalGasParameters,\n        )\n      : undefined\n\n  return writeContract(client, {\n    account: account!,\n    abi: portalAbi,\n    address: portalAddress,\n    chain,\n    functionName: 'finalizeWithdrawalTransaction',\n    args: [withdrawal],\n    gas: gas_,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n  } satisfies WriteContractParameters as any)\n}\n", "import {\n  type ReadContractErrorType,\n  readContract,\n} from '../../../actions/public/readContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { l2OutputOracleAbi } from '../abis.js'\nimport type { GetContractAddressParameter } from '../types/contract.js'\n\nexport type GetL2OutputParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = GetChainParameter<chain, chainOverride> &\n  GetContractAddressParameter<_derivedChain, 'l2OutputOracle'> & {\n    l2BlockNumber: bigint\n  }\nexport type GetL2OutputReturnType = {\n  outputIndex: bigint\n  outputRoot: Hex\n  timestamp: bigint\n  l2BlockNumber: bigint\n}\nexport type GetL2OutputErrorType = ReadContractErrorType | ErrorType\n\n/**\n * Retrieves the first L2 output proposal that occurred after a provided block number.\n *\n * - Docs: https://viem.sh/op-stack/actions/getL2Output\n *\n * @param client - Client to use\n * @param parameters - {@link GetL2OutputParameters}\n * @returns The L2 output. {@link GetL2OutputReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet, optimism } from 'viem/chains'\n * import { getL2Output } from 'viem/op-stack'\n *\n * const publicClientL1 = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const output = await getL2Output(publicClientL1, {\n *   l2BlockNumber: 69420n,\n *   targetChain: optimism\n * })\n */\nexport async function getL2Output<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetL2OutputParameters<chain, chainOverride>,\n): Promise<GetL2OutputReturnType> {\n  const { chain = client.chain, l2BlockNumber, targetChain } = parameters\n\n  const l2OutputOracleAddress = (() => {\n    if (parameters.l2OutputOracleAddress)\n      return parameters.l2OutputOracleAddress\n    if (chain) return targetChain!.contracts.l2OutputOracle[chain.id].address\n    return Object.values(targetChain!.contracts.l2OutputOracle)[0].address\n  })()\n\n  const outputIndex = await readContract(client, {\n    address: l2OutputOracleAddress,\n    abi: l2OutputOracleAbi,\n    functionName: 'getL2OutputIndexAfter',\n    args: [l2BlockNumber],\n  })\n  const output = await readContract(client, {\n    address: l2OutputOracleAddress,\n    abi: l2OutputOracleAbi,\n    functionName: 'getL2Output',\n    args: [outputIndex],\n  })\n\n  return { outputIndex, ...output }\n}\n", "import {\n  type MulticallErrorType,\n  multicall,\n} from '../../../actions/public/multicall.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { Hash } from '../../../types/misc.js'\nimport { l2OutputOracleAbi, portalAbi } from '../abis.js'\nimport type { GetContractAddressParameter } from '../types/contract.js'\n\nexport type GetTimeToFinalizeParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = GetChainParameter<chain, chainOverride> &\n  GetContractAddressParameter<_derivedChain, 'l2OutputOracle' | 'portal'> & {\n    withdrawalHash: Hash\n  }\nexport type GetTimeToFinalizeReturnType = {\n  /** The finalization period (in seconds). */\n  period: number\n  /** Seconds until the withdrawal can be finalized. */\n  seconds: number\n  /** Timestamp of when the withdrawal can be finalized. */\n  timestamp: number\n}\nexport type GetTimeToFinalizeErrorType = MulticallErrorType | ErrorType\n\nconst buffer = 10\n\n/**\n * Returns the time until the withdrawal transaction can be finalized. Used for the [Withdrawal](/op-stack/guides/withdrawals) flow.\n *\n * - Docs: https://viem.sh/op-stack/actions/getTimeToFinalize\n *\n * @param client - Client to use\n * @param parameters - {@link GetTimeToFinalizeParameters}\n * @returns Time until finalize. {@link GetTimeToFinalizeReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { getBlockNumber } from 'viem/actions'\n * import { mainnet, optimism } from 'viem/chains'\n * import { getTimeToFinalize } from 'viem/op-stack'\n *\n * const publicClientL1 = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const publicClientL2 = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n *\n * const receipt = await publicClientL2.getTransactionReceipt({\n *   hash: '0x9a2f4283636ddeb9ac32382961b22c177c9e86dd3b283735c154f897b1a7ff4a',\n * })\n *\n * const [withdrawal] = getWithdrawals(receipt)\n *\n * const { seconds } = await getTimeToFinalize(publicClientL1, {\n *   withdrawalHash: withdrawal.withdrawalHash,\n *   targetChain: optimism\n * })\n */\nexport async function getTimeToFinalize<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetTimeToFinalizeParameters<chain, chainOverride>,\n): Promise<GetTimeToFinalizeReturnType> {\n  const { chain = client.chain, withdrawalHash, targetChain } = parameters\n\n  const l2OutputOracleAddress = (() => {\n    if (parameters.l2OutputOracleAddress)\n      return parameters.l2OutputOracleAddress\n    if (chain) return targetChain!.contracts.l2OutputOracle[chain.id].address\n    return Object.values(targetChain!.contracts.l2OutputOracle)[0].address\n  })()\n  const portalAddress = (() => {\n    if (parameters.portalAddress) return parameters.portalAddress\n    if (chain) return targetChain!.contracts.portal[chain.id].address\n    return Object.values(targetChain!.contracts.portal)[0].address\n  })()\n\n  const [[_outputRoot, proveTimestamp, _l2OutputIndex], period] =\n    await multicall(client, {\n      allowFailure: false,\n      contracts: [\n        {\n          abi: portalAbi,\n          address: portalAddress,\n          functionName: 'provenWithdrawals',\n          args: [withdrawalHash],\n        },\n        {\n          abi: l2OutputOracleAbi,\n          address: l2OutputOracleAddress,\n          functionName: 'FINALIZATION_PERIOD_SECONDS',\n        },\n      ],\n    })\n\n  const secondsSinceProven = Date.now() / 1000 - Number(proveTimestamp)\n  const secondsToFinalize = Number(period) - secondsSinceProven\n\n  const seconds = Math.floor(\n    secondsToFinalize < 0 ? 0 : secondsToFinalize + buffer,\n  )\n  const timestamp = Date.now() + seconds * 1000\n\n  return { period: Number(period), seconds, timestamp }\n}\n", "import {\n  type MulticallErrorType,\n  multicall,\n} from '../../../actions/public/multicall.js'\nimport {\n  type ReadContractErrorType,\n  readContract,\n} from '../../../actions/public/readContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport { l2OutputOracleAbi } from '../abis.js'\nimport type { GetContractAddressParameter } from '../types/contract.js'\n\nexport type GetTimeToNextL2OutputParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = GetChainParameter<chain, chainOverride> &\n  GetContractAddressParameter<_derivedChain, 'l2OutputOracle'> & {\n    /**\n     * The buffer to account for discrepencies between non-deterministic time intervals.\n     * @default 1.1\n     */\n    intervalBuffer?: number\n    l2BlockNumber: bigint\n  }\nexport type GetTimeToNextL2OutputReturnType = {\n  /** The interval (in seconds) between L2 outputs. */\n  interval: number\n  /**\n   * Seconds until the next L2 output.\n   * `0` if the next L2 output has already been submitted.\n   */\n  seconds: number\n  /**\n   * Estimated timestamp of the next L2 output.\n   * `undefined` if the next L2 output has already been submitted.\n   */\n  timestamp?: number\n}\nexport type GetTimeToNextL2OutputErrorType =\n  | MulticallErrorType\n  | ReadContractErrorType\n  | ErrorType\n\n/**\n * Returns the time until the next L2 output (after the provided block number) is submitted. Used for the [Withdrawal](/op-stack/guides/withdrawals) flow.\n *\n * - Docs: https://viem.sh/op-stack/actions/getTimeToNextL2Output\n *\n * @param client - Client to use\n * @param parameters - {@link GetTimeToNextL2OutputParameters}\n * @returns The L2 transaction hash. {@link GetTimeToNextL2OutputReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { getBlockNumber } from 'viem/actions'\n * import { mainnet, optimism } from 'viem/chains'\n * import { getTimeToNextL2Output } from 'viem/op-stack'\n *\n * const publicClientL1 = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const publicClientL2 = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n *\n * const { seconds } = await getTimeToNextL2Output(publicClientL1, {\n *   targetChain: optimism\n * })\n */\nexport async function getTimeToNextL2Output<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetTimeToNextL2OutputParameters<chain, chainOverride>,\n): Promise<GetTimeToNextL2OutputReturnType> {\n  const {\n    intervalBuffer = 1.1,\n    chain = client.chain,\n    l2BlockNumber,\n    targetChain,\n  } = parameters\n\n  const l2OutputOracleAddress = (() => {\n    if (parameters.l2OutputOracleAddress)\n      return parameters.l2OutputOracleAddress\n    if (chain) return targetChain!.contracts.l2OutputOracle[chain.id].address\n    return Object.values(targetChain!.contracts.l2OutputOracle)[0].address\n  })()\n\n  const [latestOutputIndex, blockTime, blockInterval] = await multicall(\n    client,\n    {\n      allowFailure: false,\n      contracts: [\n        {\n          abi: l2OutputOracleAbi,\n          address: l2OutputOracleAddress,\n          functionName: 'latestOutputIndex',\n        },\n        {\n          abi: l2OutputOracleAbi,\n          address: l2OutputOracleAddress,\n          functionName: 'L2_BLOCK_TIME',\n        },\n        {\n          abi: l2OutputOracleAbi,\n          address: l2OutputOracleAddress,\n          functionName: 'SUBMISSION_INTERVAL',\n        },\n      ],\n    },\n  )\n  const latestOutput = await readContract(client, {\n    abi: l2OutputOracleAbi,\n    address: l2OutputOracleAddress,\n    functionName: 'getL2Output',\n    args: [latestOutputIndex],\n  })\n  const latestOutputTimestamp = Number(latestOutput.timestamp) * 1000\n\n  const interval = Number(blockInterval * blockTime)\n  const intervalWithBuffer = Math.ceil(interval * intervalBuffer)\n\n  const now = Date.now()\n\n  const seconds = (() => {\n    // If the current timestamp is lesser than the latest L2 output timestamp,\n    // then we assume that the L2 output has already been submitted.\n    if (now < latestOutputTimestamp) return 0\n\n    // If the latest L2 output block is newer than the provided L2 block number,\n    // then we assume that the L2 output has already been submitted.\n    if (latestOutput.l2BlockNumber > l2BlockNumber) return 0\n\n    const elapsedBlocks = Number(l2BlockNumber - latestOutput.l2BlockNumber)\n\n    const elapsed = Math.ceil((now - latestOutputTimestamp) / 1000)\n    const secondsToNextOutput =\n      intervalWithBuffer - (elapsed % intervalWithBuffer)\n    return elapsedBlocks < blockInterval\n      ? secondsToNextOutput\n      : Math.floor(elapsedBlocks / Number(blockInterval)) * intervalWithBuffer +\n          secondsToNextOutput\n  })()\n\n  const timestamp = seconds > 0 ? now + seconds * 1000 : undefined\n\n  return { interval, seconds, timestamp }\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { TransactionReceipt } from '../../../types/transaction.js'\nimport type { GetContractAddressParameter } from '../types/contract.js'\nimport {\n  type GetTimeToNextL2OutputErrorType,\n  type GetTimeToNextL2OutputParameters,\n  type GetTimeToNextL2OutputReturnType,\n  getTimeToNextL2Output,\n} from './getTimeToNextL2Output.js'\n\nexport type GetTimeToProveParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = GetChainParameter<chain, chainOverride> &\n  GetContractAddressParameter<_derivedChain, 'l2OutputOracle'> & {\n    /**\n     * The buffer to account for discrepencies between non-deterministic time intervals.\n     * @default 1.1\n     */\n    intervalBuffer?: GetTimeToNextL2OutputParameters['intervalBuffer']\n    receipt: TransactionReceipt\n  }\nexport type GetTimeToProveReturnType = GetTimeToNextL2OutputReturnType\nexport type GetTimeToProveErrorType = GetTimeToNextL2OutputErrorType | ErrorType\n\n/**\n * Returns the time until the withdrawal transaction is ready to prove. Used for the [Withdrawal](/op-stack/guides/withdrawals) flow.\n *\n * - Docs: https://viem.sh/op-stack/actions/getTimeToProve\n *\n * @param client - Client to use\n * @param parameters - {@link GetTimeToNextL2OutputParameters}\n * @returns Time until prove step is ready. {@link GetTimeToNextL2OutputReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { getBlockNumber } from 'viem/actions'\n * import { mainnet, optimism } from 'viem/chains'\n * import { getTimeToProve } from 'viem/op-stack'\n *\n * const publicClientL1 = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const publicClientL2 = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n *\n * const receipt = await publicClientL2.getTransactionReceipt({ hash: '0x...' })\n * const { period, seconds, timestamp } = await getTimeToProve(publicClientL1, {\n *   receipt,\n *   targetChain: optimism\n * })\n */\nexport async function getTimeToProve<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetTimeToProveParameters<chain, chainOverride>,\n): Promise<GetTimeToProveReturnType> {\n  const { receipt } = parameters\n\n  return getTimeToNextL2Output(client, {\n    ...parameters,\n    l2BlockNumber: receipt.blockNumber,\n  })\n}\n", "import { BaseError } from '../../../errors/base.js'\nimport type { Hex } from '../../../types/misc.js'\n\nexport type ReceiptContainsNoWithdrawalsErrorType =\n  ReceiptContainsNoWithdrawalsError & {\n    name: 'ReceiptContainsNoWithdrawalsError'\n  }\nexport class ReceiptContainsNoWithdrawalsError extends BaseError {\n  override name = 'ReceiptContainsNoWithdrawalsError'\n  constructor({ hash }: { hash: Hex }) {\n    super(\n      `The provided transaction receipt with hash \"${hash}\" contains no withdrawals.`,\n    )\n  }\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport type { Log } from '../../../types/log.js'\nimport {\n  type ParseEventLogsErrorType,\n  parseEventLogs,\n} from '../../../utils/abi/parseEventLogs.js'\nimport { l2ToL1MessagePasserAbi } from '../abis.js'\n\nexport type ExtractWithdrawalMessageLogsParameters = {\n  /** An opaque array of logs. */\n  logs: Log[]\n}\n\nexport type ExtractWithdrawalMessageLogsReturnType = Log<\n  bigint,\n  number,\n  false,\n  undefined,\n  true,\n  typeof l2ToL1MessagePasserAbi,\n  'MessagePassed'\n>[]\n\nexport type ExtractWithdrawalMessageLogsErrorType =\n  | ParseEventLogsErrorType\n  | ErrorType\n\nexport function extractWithdrawalMessageLogs({\n  logs,\n}: ExtractWithdrawalMessageLogsParameters) {\n  return parseEventLogs({\n    abi: l2ToL1MessagePasserAbi,\n    eventName: 'MessagePassed',\n    logs,\n  })\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport type { Log } from '../../../types/log.js'\nimport type { Withdrawal } from '../types/withdrawal.js'\nimport {\n  type ExtractWithdrawalMessageLogsErrorType,\n  extractWithdrawalMessageLogs,\n} from './extractWithdrawalMessageLogs.js'\n\nexport type GetWithdrawalsParameters = {\n  /** The L2 transaction receipt logs. */\n  logs: Log[]\n}\n\nexport type GetWithdrawalsReturnType = Withdrawal[]\n\nexport type GetWithdrawalsErrorType =\n  | ExtractWithdrawalMessageLogsErrorType\n  | ErrorType\n\nexport function getWithdrawals({\n  logs,\n}: GetWithdrawalsParameters): GetWithdrawalsReturnType {\n  const extractedLogs = extractWithdrawalMessageLogs({ logs })\n  return extractedLogs.map((log) => log.args)\n}\n", "import {\n  type ReadContractErrorType,\n  readContract,\n} from '../../../actions/public/readContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { ContractFunctionRevertedError } from '../../../errors/contract.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { TransactionReceipt } from '../../../types/transaction.js'\nimport { portalAbi } from '../abis.js'\nimport { ReceiptContainsNoWithdrawalsError } from '../errors/withdrawal.js'\nimport type { GetContractAddressParameter } from '../types/contract.js'\nimport {\n  type GetWithdrawalsErrorType,\n  getWithdrawals,\n} from '../utils/getWithdrawals.js'\nimport { type GetL2OutputErrorType, getL2Output } from './getL2Output.js'\nimport {\n  type GetTimeToFinalizeErrorType,\n  getTimeToFinalize,\n} from './getTimeToFinalize.js'\n\nexport type GetWithdrawalStatusParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = GetChainParameter<chain, chainOverride> &\n  GetContractAddressParameter<_derivedChain, 'l2OutputOracle' | 'portal'> & {\n    receipt: TransactionReceipt\n  }\nexport type GetWithdrawalStatusReturnType =\n  | 'waiting-to-prove'\n  | 'ready-to-prove'\n  | 'waiting-to-finalize'\n  | 'ready-to-finalize'\n  | 'finalized'\nexport type GetWithdrawalStatusErrorType =\n  | GetL2OutputErrorType\n  | GetTimeToFinalizeErrorType\n  | GetWithdrawalsErrorType\n  | ReadContractErrorType\n  | ErrorType\n\n/**\n * Returns the current status of a withdrawal. Used for the [Withdrawal](/op-stack/guides/withdrawals) flow.\n *\n * - Docs: https://viem.sh/op-stack/actions/getWithdrawalStatus\n *\n * @param client - Client to use\n * @param parameters - {@link GetWithdrawalStatusParameters}\n * @returns Status of the withdrawal. {@link GetWithdrawalStatusReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { getBlockNumber } from 'viem/actions'\n * import { mainnet, optimism } from 'viem/chains'\n * import { getWithdrawalStatus } from 'viem/op-stack'\n *\n * const publicClientL1 = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const publicClientL2 = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n *\n * const receipt = await publicClientL2.getTransactionReceipt({ hash: '0x...' })\n * const status = await getWithdrawalStatus(publicClientL1, {\n *   receipt,\n *   targetChain: optimism\n * })\n */\nexport async function getWithdrawalStatus<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetWithdrawalStatusParameters<chain, chainOverride>,\n): Promise<GetWithdrawalStatusReturnType> {\n  const { chain = client.chain, receipt, targetChain } = parameters\n\n  const portalAddress = (() => {\n    if (parameters.portalAddress) return parameters.portalAddress\n    if (chain) return targetChain!.contracts.portal[chain.id].address\n    return Object.values(targetChain!.contracts.portal)[0].address\n  })()\n\n  const [withdrawal] = getWithdrawals(receipt)\n\n  if (!withdrawal)\n    throw new ReceiptContainsNoWithdrawalsError({\n      hash: receipt.transactionHash,\n    })\n\n  const [outputResult, proveResult, finalizedResult, timeToFinalizeResult] =\n    await Promise.allSettled([\n      getL2Output(client, {\n        ...parameters,\n        l2BlockNumber: receipt.blockNumber,\n      }),\n      readContract(client, {\n        abi: portalAbi,\n        address: portalAddress,\n        functionName: 'provenWithdrawals',\n        args: [withdrawal.withdrawalHash],\n      }),\n      readContract(client, {\n        abi: portalAbi,\n        address: portalAddress,\n        functionName: 'finalizedWithdrawals',\n        args: [withdrawal.withdrawalHash],\n      }),\n      getTimeToFinalize(client, {\n        ...parameters,\n        withdrawalHash: withdrawal.withdrawalHash,\n      }),\n    ])\n\n  // If the L2 Output is not processed yet (ie. the actions throws), this means\n  // that the withdrawal is not ready to prove.\n  if (outputResult.status === 'rejected') {\n    const error = outputResult.reason as GetL2OutputErrorType\n    if (\n      error.cause instanceof ContractFunctionRevertedError &&\n      error.cause.data?.args?.[0] ===\n        'L2OutputOracle: cannot get output for a block that has not been proposed'\n    )\n      return 'waiting-to-prove'\n    throw error\n  }\n  if (proveResult.status === 'rejected') throw proveResult.reason\n  if (finalizedResult.status === 'rejected') throw finalizedResult.reason\n  if (timeToFinalizeResult.status === 'rejected')\n    throw timeToFinalizeResult.reason\n\n  const [_, proveTimestamp] = proveResult.value\n  if (!proveTimestamp) return 'ready-to-prove'\n\n  const finalized = finalizedResult.value\n  if (finalized) return 'finalized'\n\n  const { seconds } = timeToFinalizeResult.value\n  return seconds > 0 ? 'waiting-to-finalize' : 'ready-to-finalize'\n}\n", "import type { Address } from 'abitype'\nimport {\n  type EstimateContractGasErrorType,\n  type EstimateContractGasParameters,\n  estimateContractGas,\n} from '../../../actions/public/estimateContractGas.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { UnionEvaluate, UnionOmit } from '../../../types/utils.js'\nimport type { FormattedTransactionRequest } from '../../../utils/formatters/transactionRequest.js'\nimport { l2ToL1MessagePasserAbi } from '../abis.js'\nimport { contracts } from '../contracts.js'\nimport type { WithdrawalRequest } from '../types/withdrawal.js'\n\nexport type EstimateInitiateWithdrawalGasParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionEvaluate<\n  UnionOmit<\n    FormattedTransactionRequest<_derivedChain>,\n    | 'accessList'\n    | 'data'\n    | 'from'\n    | 'gas'\n    | 'gasPrice'\n    | 'to'\n    | 'type'\n    | 'value'\n  >\n> &\n  GetAccountParameter<account, Account | Address> &\n  GetChainParameter<chain, chainOverride> & {\n    /** Gas limit for transaction execution on the L2. */\n    gas?: bigint | null\n    /**\n     * Withdrawal request.\n     * Supplied to the L2ToL1MessagePasser `initiateWithdrawal` method.\n     */\n    request: WithdrawalRequest\n  }\nexport type EstimateInitiateWithdrawalGasReturnType = bigint\nexport type EstimateInitiateWithdrawalGasErrorType =\n  | EstimateContractGasErrorType\n  | ErrorType\n\n/**\n * Estimates gas required to initiate a [withdrawal](https://community.optimism.io/docs/protocol/withdrawal-flow/#withdrawal-initiating-transaction) on an L2 to the L1.\n *\n * - Docs: https://viem.sh/op-stack/actions/estimateInitiateWithdrawalGas\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateInitiateWithdrawalGasParameters}\n * @returns Estimated gas. {@link EstimateInitiateWithdrawalGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { base, mainnet } from 'viem/chains'\n * import { estimateInitiateWithdrawalGas } from 'viem/op-stack'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const gas = await estimateInitiateWithdrawalGas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   request: {\n *     gas: 21_000n,\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     value: parseEther('1'),\n *   },\n * })\n */\nexport async function estimateInitiateWithdrawalGas<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: EstimateInitiateWithdrawalGasParameters<\n    chain,\n    account,\n    chainOverride\n  >,\n) {\n  const {\n    account,\n    chain = client.chain,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    request: { data = '0x', gas: l1Gas, to, value },\n  } = parameters\n\n  return estimateContractGas(client, {\n    account,\n    abi: l2ToL1MessagePasserAbi,\n    address: contracts.l2ToL1MessagePasser.address,\n    chain,\n    functionName: 'initiateWithdrawal',\n    args: [to, l1Gas, data],\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    value,\n  } as EstimateContractGasParameters)\n}\n", "import type { Address } from 'abitype'\nimport {\n  type WriteContractErrorType,\n  type WriteContractParameters,\n  writeContract,\n} from '../../../actions/wallet/writeContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { UnionEvaluate, UnionOmit } from '../../../types/utils.js'\nimport type { FormattedTransactionRequest } from '../../../utils/formatters/transactionRequest.js'\nimport { l2ToL1MessagePasserAbi } from '../abis.js'\nimport { contracts } from '../contracts.js'\nimport type { WithdrawalRequest } from '../types/withdrawal.js'\nimport {\n  type EstimateInitiateWithdrawalGasErrorType,\n  type EstimateInitiateWithdrawalGasParameters,\n  estimateInitiateWithdrawalGas,\n} from './estimateInitiateWithdrawalGas.js'\n\nexport type InitiateWithdrawalParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionEvaluate<\n  UnionOmit<\n    FormattedTransactionRequest<_derivedChain>,\n    | 'accessList'\n    | 'data'\n    | 'from'\n    | 'gas'\n    | 'gasPrice'\n    | 'to'\n    | 'type'\n    | 'value'\n  >\n> &\n  GetAccountParameter<account, Account | Address> &\n  GetChainParameter<chain, chainOverride> & {\n    /**\n     * Gas limit for transaction execution on the L2.\n     * `null` to skip gas estimation & defer calculation to signer.\n     */\n    gas?: bigint | null\n    /** Withdrawal request. Supplied to the L2ToL1MessagePasser `initiateWithdrawal` method. */\n    request: WithdrawalRequest\n  }\nexport type InitiateWithdrawalReturnType = Hash\nexport type InitiateWithdrawalErrorType =\n  | EstimateInitiateWithdrawalGasErrorType\n  | WriteContractErrorType\n  | ErrorType\n\n/**\n * Initiates a [withdrawal](https://community.optimism.io/docs/protocol/withdrawal-flow/#withdrawal-initiating-transaction) on an L2 to the L1.\n *\n * Internally performs a contract write to the [`initiateWithdrawal` function](https://github.com/ethereum-optimism/optimism/blob/283f0aa2e3358ced30ff7cbd4028c0c0c3faa140/packages/contracts-bedrock/src/L2/L2ToL1MessagePasser.sol#L73)\n * on the [Optimism L2ToL1MessagePasser predeploy contract](https://github.com/ethereum-optimism/optimism/blob/283f0aa2e3358ced30ff7cbd4028c0c0c3faa140/packages/contracts-bedrock/src/L2/L2ToL1MessagePasser.sol).\n *\n * - Docs: https://viem.sh/op-stack/actions/initiateWithdrawal\n *\n * @param client - Client to use\n * @param parameters - {@link InitiateWithdrawalParameters}\n * @returns The L2 transaction hash. {@link InitiateWithdrawalReturnType}\n *\n * @example\n * import { createWalletClient, custom, parseEther } from 'viem'\n * import { base, mainnet } from 'viem/chains'\n * import { initiateWithdrawal } from 'viem/op-stack'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const hash = await initiateWithdrawal(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   args: {\n *     gas: 21_000n,\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     value: parseEther('1'),\n *   },\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { base, mainnet } from 'viem/chains'\n * import { initiateWithdrawal } from 'viem/op-stack'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const hash = await initiateWithdrawal(client, {\n *   request: {\n *     gas: 21_000n,\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     value: parseEther('1'),\n *   },\n * })\n */\nexport async function initiateWithdrawal<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: InitiateWithdrawalParameters<chain, account, chainOverride>,\n) {\n  const {\n    account,\n    chain = client.chain,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    request: { data = '0x', gas: l1Gas, to, value },\n  } = parameters\n\n  const gas_ =\n    typeof gas !== 'number' && gas !== null\n      ? await estimateInitiateWithdrawalGas(\n          client,\n          parameters as EstimateInitiateWithdrawalGasParameters,\n        )\n      : undefined\n\n  return writeContract(client, {\n    account: account!,\n    abi: l2ToL1MessagePasserAbi,\n    address: contracts.l2ToL1MessagePasser.address,\n    chain,\n    functionName: 'initiateWithdrawal',\n    args: [to, l1Gas, data],\n    gas: gas_,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    value,\n  } satisfies WriteContractParameters as any)\n}\n", "import type { Address } from 'abitype'\nimport {\n  type EstimateContractGasErrorType,\n  type EstimateContractGasParameters,\n  estimateContractGas,\n} from '../../../actions/public/estimateContractGas.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { UnionEvaluate, UnionOmit } from '../../../types/utils.js'\nimport type { FormattedTransactionRequest } from '../../../utils/formatters/transactionRequest.js'\nimport { portalAbi } from '../abis.js'\nimport type { GetContractAddressParameter } from '../types/contract.js'\n\nexport type EstimateProveWithdrawalGasParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionEvaluate<\n  UnionOmit<\n    FormattedTransactionRequest<_derivedChain>,\n    | 'accessList'\n    | 'data'\n    | 'from'\n    | 'gas'\n    | 'gasPrice'\n    | 'to'\n    | 'type'\n    | 'value'\n  >\n> &\n  GetAccountParameter<account, Account | Address> &\n  GetChainParameter<chain, chainOverride> &\n  GetContractAddressParameter<_derivedChain, 'portal'> & {\n    /** Gas limit for transaction execution on the L2. */\n    gas?: bigint | null\n    l2OutputIndex: bigint\n    outputRootProof: {\n      version: Hex\n      stateRoot: Hex\n      messagePasserStorageRoot: Hex\n      latestBlockhash: Hex\n    }\n    withdrawalProof: readonly Hex[]\n    withdrawal: {\n      data: Hex\n      gasLimit: bigint\n      nonce: bigint\n      sender: Address\n      target: Address\n      value: bigint\n    }\n  }\nexport type EstimateProveWithdrawalGasReturnType = bigint\nexport type EstimateProveWithdrawalGasErrorType =\n  | EstimateContractGasErrorType\n  | ErrorType\n\n/**\n * Estimates gas required to prove a withdrawal that occurred on an L2.\n *\n * - Docs: https://viem.sh/op-stack/actions/estimateProveWithdrawalGas\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateProveWithdrawalGasParameters}\n * @returns Estimated gas. {@link EstimateProveWithdrawalGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { base, mainnet } from 'viem/chains'\n * import { estimateProveWithdrawalGas } from 'viem/op-stack'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const gas = await estimateProveWithdrawalGas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   l2OutputIndex: 4529n,\n *   outputRootProof: { ... },\n *   targetChain: optimism,\n *   withdrawalProof: [ ... ],\n *   withdrawal: { ... },\n * })\n */\nexport async function estimateProveWithdrawalGas<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: EstimateProveWithdrawalGasParameters<\n    chain,\n    account,\n    chainOverride\n  >,\n) {\n  const {\n    account,\n    chain = client.chain,\n    gas,\n    l2OutputIndex,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    outputRootProof,\n    targetChain,\n    withdrawalProof,\n    withdrawal,\n  } = parameters\n\n  const portalAddress = (() => {\n    if (parameters.portalAddress) return parameters.portalAddress\n    if (chain) return targetChain!.contracts.portal[chain.id].address\n    return Object.values(targetChain!.contracts.portal)[0].address\n  })()\n\n  return estimateContractGas(client, {\n    account,\n    abi: portalAbi,\n    address: portalAddress,\n    chain,\n    functionName: 'proveWithdrawalTransaction',\n    args: [withdrawal, l2OutputIndex, outputRootProof, withdrawalProof],\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n  } as EstimateContractGasParameters)\n}\n", "import type { Address } from 'abitype'\nimport {\n  type WriteContractErrorType,\n  type WriteContractParameters,\n  writeContract,\n} from '../../../actions/wallet/writeContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { Hash, Hex } from '../../../types/misc.js'\nimport type { UnionEvaluate, UnionOmit } from '../../../types/utils.js'\nimport type { FormattedTransactionRequest } from '../../../utils/formatters/transactionRequest.js'\nimport { portalAbi } from '../abis.js'\nimport type { GetContractAddressParameter } from '../types/contract.js'\nimport {\n  type EstimateProveWithdrawalGasErrorType,\n  type EstimateProveWithdrawalGasParameters,\n  estimateProveWithdrawalGas,\n} from './estimateProveWithdrawalGas.js'\n\nexport type ProveWithdrawalParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionEvaluate<\n  UnionOmit<\n    FormattedTransactionRequest<_derivedChain>,\n    | 'accessList'\n    | 'data'\n    | 'from'\n    | 'gas'\n    | 'gasPrice'\n    | 'to'\n    | 'type'\n    | 'value'\n  >\n> &\n  GetAccountParameter<account, Account | Address> &\n  GetChainParameter<chain, chainOverride> &\n  GetContractAddressParameter<_derivedChain, 'portal'> & {\n    /**\n     * Gas limit for transaction execution on the L1.\n     * `null` to skip gas estimation & defer calculation to signer.\n     */\n    gas?: bigint | null\n    l2OutputIndex: bigint\n    outputRootProof: {\n      version: Hex\n      stateRoot: Hex\n      messagePasserStorageRoot: Hex\n      latestBlockhash: Hex\n    }\n    withdrawalProof: readonly Hex[]\n    withdrawal: {\n      data: Hex\n      gasLimit: bigint\n      nonce: bigint\n      sender: Address\n      target: Address\n      value: bigint\n    }\n  }\nexport type ProveWithdrawalReturnType = Hash\nexport type ProveWithdrawalErrorType =\n  | EstimateProveWithdrawalGasErrorType\n  | WriteContractErrorType\n  | ErrorType\n\n/**\n * Proves a withdrawal that occurred on an L2. Used in the Withdrawal flow.\n *\n * - Docs: https://viem.sh/op-stack/actions/proveWithdrawal\n *\n * @param client - Client to use\n * @param parameters - {@link ProveWithdrawalParameters}\n * @returns The prove transaction hash. {@link ProveWithdrawalReturnType}\n *\n * @example\n * import { createWalletClient, http } from 'viem'\n * import { mainnet, optimism } from 'viem/chains'\n * import { proveWithdrawal } from 'viem/op-stack'\n *\n * const walletClientL1 = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const request = await proveWithdrawal(walletClientL1, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   l2OutputIndex: 4529n,\n *   outputRootProof: { ... },\n *   targetChain: optimism,\n *   withdrawalProof: [ ... ],\n *   withdrawal: { ... },\n * })\n */\nexport async function proveWithdrawal<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: ProveWithdrawalParameters<chain, account, chainOverride>,\n): Promise<ProveWithdrawalReturnType> {\n  const {\n    account,\n    chain = client.chain,\n    gas,\n    l2OutputIndex,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    outputRootProof,\n    targetChain,\n    withdrawalProof,\n    withdrawal,\n  } = parameters\n\n  const portalAddress = (() => {\n    if (parameters.portalAddress) return parameters.portalAddress\n    if (chain) return targetChain!.contracts.portal[chain.id].address\n    return Object.values(targetChain!.contracts.portal)[0].address\n  })()\n\n  const gas_ =\n    typeof gas !== 'number' && gas !== null\n      ? await estimateProveWithdrawalGas(\n          client,\n          parameters as EstimateProveWithdrawalGasParameters,\n        )\n      : gas ?? undefined\n\n  return writeContract(client, {\n    account: account!,\n    abi: portalAbi,\n    address: portalAddress,\n    chain,\n    functionName: 'proveWithdrawalTransaction',\n    args: [withdrawal, l2OutputIndex, outputRootProof, withdrawalProof],\n    gas: gas_,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n  } satisfies WriteContractParameters as any)\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { ContractFunctionRevertedError } from '../../../errors/contract.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport { poll } from '../../../utils/poll.js'\nimport type { GetContractAddressParameter } from '../types/contract.js'\nimport {\n  type GetL2OutputErrorType,\n  type GetL2OutputReturnType,\n  getL2Output,\n} from './getL2Output.js'\nimport {\n  type GetTimeToNextL2OutputErrorType,\n  type GetTimeToNextL2OutputParameters,\n  getTimeToNextL2Output,\n} from './getTimeToNextL2Output.js'\n\nexport type WaitForNextL2OutputParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = GetChainParameter<chain, chainOverride> &\n  GetContractAddressParameter<_derivedChain, 'l2OutputOracle'> & {\n    /**\n     * The buffer to account for discrepencies between non-deterministic time intervals.\n     * @default 1.1\n     */\n    intervalBuffer?: GetTimeToNextL2OutputParameters['intervalBuffer']\n    l2BlockNumber: bigint\n    /**\n     * Polling frequency (in ms). Defaults to Client's pollingInterval config.\n     * @default client.pollingInterval\n     */\n    pollingInterval?: number\n  }\nexport type WaitForNextL2OutputReturnType = GetL2OutputReturnType\nexport type WaitForNextL2OutputErrorType =\n  | GetL2OutputErrorType\n  | GetTimeToNextL2OutputErrorType\n  | ErrorType\n\n/**\n * Waits for the next L2 output (after the provided block number) to be submitted.\n *\n * - Docs: https://viem.sh/op-stack/actions/waitForNextL2Output\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForNextL2OutputParameters}\n * @returns The L2 transaction hash. {@link WaitForNextL2OutputReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { getBlockNumber } from 'viem/actions'\n * import { mainnet, optimism } from 'viem/chains'\n * import { waitForNextL2Output } from 'viem/op-stack'\n *\n * const publicClientL1 = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const publicClientL2 = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n *\n * const l2BlockNumber = await getBlockNumber(publicClientL2)\n * await waitForNextL2Output(publicClientL1, {\n *   l2BlockNumber,\n *   targetChain: optimism\n * })\n */\nexport async function waitForNextL2Output<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: WaitForNextL2OutputParameters<chain, chainOverride>,\n): Promise<WaitForNextL2OutputReturnType> {\n  const { pollingInterval = client.pollingInterval } = parameters\n\n  const { seconds } = await getTimeToNextL2Output(client, parameters)\n\n  return new Promise((resolve, reject) => {\n    poll(\n      async ({ unpoll }) => {\n        try {\n          const output = await getL2Output(client, parameters)\n          unpoll()\n          resolve(output)\n        } catch (e) {\n          const error = e as GetL2OutputErrorType\n          if (!(error.cause instanceof ContractFunctionRevertedError)) {\n            unpoll()\n            reject(e)\n          }\n        }\n      },\n      {\n        interval: pollingInterval,\n        initialWaitTime: async () => seconds * 1000,\n      },\n    )\n  })\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account } from '../../../types/account.js'\nimport type { Chain } from '../../../types/chain.js'\nimport { wait } from '../../../utils/wait.js'\nimport {\n  type GetTimeToFinalizeErrorType,\n  type GetTimeToFinalizeParameters,\n  getTimeToFinalize,\n} from './getTimeToFinalize.js'\n\nexport type WaitToFinalizeParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n> = GetTimeToFinalizeParameters<chain, chainOverride>\nexport type WaitToFinalizeReturnType = void\nexport type WaitToFinalizeErrorType = GetTimeToFinalizeErrorType | ErrorType\n\n/**\n * Waits until the withdrawal transaction can be finalized. Used for the [Withdrawal](/op-stack/guides/withdrawals) flow.\n *\n * - Docs: https://viem.sh/op-stack/actions/waitToFinalize\n *\n * @param client - Client to use\n * @param parameters - {@link WaitToFinalizeParameters}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { getBlockNumber } from 'viem/actions'\n * import { mainnet, optimism } from 'viem/chains'\n * import { waitToFinalize } from 'viem/op-stack'\n *\n * const publicClientL1 = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const publicClientL2 = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n *\n * const receipt = await publicClientL2.getTransactionReceipt({\n *   hash: '0x9a2f4283636ddeb9ac32382961b22c177c9e86dd3b283735c154f897b1a7ff4a',\n * })\n *\n * const [withdrawal] = getWithdrawals(receipt)\n *\n * await waitToFinalize(publicClientL1, {\n *   withdrawalHash: withdrawal.withdrawalHash,\n *   targetChain: optimism\n * })\n */\nexport async function waitToFinalize<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: WaitToFinalizeParameters<chain, chainOverride>,\n): Promise<WaitToFinalizeReturnType> {\n  const { seconds } = await getTimeToFinalize(client, parameters)\n  await wait(seconds * 1000)\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account } from '../../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../../types/chain.js'\nimport type { TransactionReceipt } from '../../../types/transaction.js'\nimport { ReceiptContainsNoWithdrawalsError } from '../errors/withdrawal.js'\nimport type { GetContractAddressParameter } from '../types/contract.js'\nimport type { Withdrawal } from '../types/withdrawal.js'\nimport {\n  type GetWithdrawalsErrorType,\n  getWithdrawals,\n} from '../utils/getWithdrawals.js'\nimport {\n  type WaitForNextL2OutputErrorType,\n  type WaitForNextL2OutputReturnType,\n  waitForNextL2Output,\n} from './waitForNextL2Output.js'\n\nexport type WaitToProveParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = GetChainParameter<chain, chainOverride> &\n  GetContractAddressParameter<_derivedChain, 'l2OutputOracle'> & {\n    receipt: TransactionReceipt\n    /**\n     * Polling frequency (in ms). Defaults to Client's pollingInterval config.\n     * @default client.pollingInterval\n     */\n    pollingInterval?: number\n  }\nexport type WaitToProveReturnType = {\n  withdrawal: Withdrawal\n  output: WaitForNextL2OutputReturnType\n}\nexport type WaitToProveErrorType =\n  | GetWithdrawalsErrorType\n  | WaitForNextL2OutputErrorType\n  | ErrorType\n\n/**\n * Waits until the L2 withdrawal transaction is ready to be proved. Used for the [Withdrawal](/op-stack/guides/withdrawals) flow.\n *\n * - Docs: https://viem.sh/op-stack/actions/waitToProve\n *\n * @param client - Client to use\n * @param parameters - {@link WaitToProveParameters}\n * @returns The L2 output and withdrawal message. {@link WaitToProveReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { getBlockNumber } from 'viem/actions'\n * import { mainnet, optimism } from 'viem/chains'\n * import { waitToProve } from 'viem/op-stack'\n *\n * const publicClientL1 = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const publicClientL2 = createPublicClient({\n *   chain: optimism,\n *   transport: http(),\n * })\n *\n * const receipt = await publicClientL2.getTransactionReceipt({ hash: '0x...' })\n * await waitToProve(publicClientL1, {\n *   receipt,\n *   targetChain: optimism\n * })\n */\nexport async function waitToProve<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: WaitToProveParameters<chain, chainOverride>,\n): Promise<WaitToProveReturnType> {\n  const { receipt } = parameters\n\n  const [withdrawal] = getWithdrawals(receipt)\n\n  if (!withdrawal)\n    throw new ReceiptContainsNoWithdrawalsError({\n      hash: receipt.transactionHash,\n    })\n\n  const output = await waitForNextL2Output(client, {\n    ...parameters,\n    l2BlockNumber: receipt.blockNumber,\n  })\n\n  return { output, withdrawal }\n}\n", "import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Account } from '../../../types/account.js'\nimport type { Chain } from '../../../types/chain.js'\nimport {\n  type BuildInitiateWithdrawalParameters,\n  type BuildInitiateWithdrawalReturnType,\n  buildInitiateWithdrawal,\n} from '../actions/buildInitiateWithdrawal.js'\nimport {\n  type EstimateDepositTransactionGasParameters,\n  type EstimateDepositTransactionGasReturnType,\n  estimateDepositTransactionGas,\n} from '../actions/estimateDepositTransactionGas.js'\nimport {\n  type EstimateFinalizeWithdrawalGasParameters,\n  type EstimateFinalizeWithdrawalGasReturnType,\n  estimateFinalizeWithdrawalGas,\n} from '../actions/estimateFinalizeWithdrawalGas.js'\nimport {\n  type EstimateProveWithdrawalGasParameters,\n  type EstimateProveWithdrawalGasReturnType,\n  estimateProveWithdrawalGas,\n} from '../actions/estimateProveWithdrawalGas.js'\nimport {\n  type GetL2OutputParameters,\n  type GetL2OutputReturnType,\n  getL2Output,\n} from '../actions/getL2Output.js'\nimport {\n  type GetTimeToFinalizeParameters,\n  type GetTimeToFinalizeReturnType,\n  getTimeToFinalize,\n} from '../actions/getTimeToFinalize.js'\nimport {\n  type GetTimeToNextL2OutputParameters,\n  type GetTimeToNextL2OutputReturnType,\n  getTimeToNextL2Output,\n} from '../actions/getTimeToNextL2Output.js'\nimport {\n  type GetTimeToProveParameters,\n  type GetTimeToProveReturnType,\n  getTimeToProve,\n} from '../actions/getTimeToProve.js'\nimport {\n  type GetWithdrawalStatusParameters,\n  type GetWithdrawalStatusReturnType,\n  getWithdrawalStatus,\n} from '../actions/getWithdrawalStatus.js'\nimport {\n  type WaitForNextL2OutputParameters,\n  type WaitForNextL2OutputReturnType,\n  waitForNextL2Output,\n} from '../actions/waitForNextL2Output.js'\nimport {\n  type WaitToFinalizeParameters,\n  type WaitToFinalizeReturnType,\n  waitToFinalize,\n} from '../actions/waitToFinalize.js'\nimport {\n  type WaitToProveParameters,\n  type WaitToProveReturnType,\n  waitToProve,\n} from '../actions/waitToProve.js'\n\nexport type PublicActionsL1<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> = {\n  /**\n   * Prepares parameters for a [deposit transaction](https://github.com/ethereum-optimism/optimism/blob/develop/specs/deposits.md) to be initiated on an L1.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/buildInitiateWithdrawal\n   *\n   * @param client - Client to use\n   * @param parameters - {@link BuildInitiateWithdrawalParameters}\n   * @returns Parameters for `depositTransaction`. {@link DepositTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, http, parseEther } from 'viem'\n   * import { base } from 'viem/chains'\n   * import { publicActionsL1 } from 'viem/op-stack'\n   *\n   * const client = createWalletClient({\n   *   chain: base,\n   *   transport: http(),\n   * }).extend(publicActionsL1())\n   *\n   * const args = await client.buildInitiateWithdrawal({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: parseEther('1'),\n   * })\n   */\n  buildInitiateWithdrawal: <\n    chainOverride extends Chain | undefined = undefined,\n    accountOverride extends Account | Address | undefined = undefined,\n  >(\n    parameters: BuildInitiateWithdrawalParameters<\n      chain,\n      account,\n      chainOverride,\n      accountOverride\n    >,\n  ) => Promise<BuildInitiateWithdrawalReturnType<account, accountOverride>>\n  /**\n   * Estimates gas required to initiate a [deposit transaction](https://github.com/ethereum-optimism/optimism/blob/develop/specs/deposits.md) on an L1, which executes a transaction on L2.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/estimateDepositTransactionGas\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateDepositTransactionGasParameters}\n   * @returns The L1 transaction hash. {@link EstimateDepositTransactionGasReturnType}\n   *\n   * @example\n   * import { createPublicClient, custom, parseEther } from 'viem'\n   * import { base, mainnet } from 'viem/chains'\n   * import { publicActionsL1 } from 'viem/op-stack'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(publicActionsL1())\n   *\n   * const gas = await client.estimateDepositTransactionGas({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   args: {\n   *     gas: 21_000n,\n   *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *     value: parseEther('1'),\n   *   },\n   *   targetChain: base,\n   * })\n   */\n  estimateDepositTransactionGas: <\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: EstimateDepositTransactionGasParameters<\n      chain,\n      account,\n      chainOverride\n    >,\n  ) => Promise<EstimateDepositTransactionGasReturnType>\n  /**\n   * Estimates gas required to prove a withdrawal that occurred on an L2.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/estimateProveWithdrawalGas\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateProveWithdrawalGasParameters}\n   * @returns Estimated gas. {@link EstimateProveWithdrawalGasReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseEther } from 'viem'\n   * import { base, mainnet } from 'viem/chains'\n   * import { publicActionsL1 } from 'viem/op-stack'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(publicActionsL1())\n   *\n   * const gas = await client.estimateProveWithdrawalGas({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   l2OutputIndex: 4529n,\n   *   outputRootProof: { ... },\n   *   targetChain: optimism,\n   *   withdrawalProof: [ ... ],\n   *   withdrawal: { ... },\n   * })\n   */\n  estimateProveWithdrawalGas: <\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: EstimateProveWithdrawalGasParameters<\n      chain,\n      account,\n      chainOverride\n    >,\n  ) => Promise<EstimateProveWithdrawalGasReturnType>\n  /**\n   * Estimates gas required to finalize a withdrawal that occurred on an L2.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/estimateFinalizeWithdrawalGas\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateFinalizeWithdrawalGasParameters}\n   * @returns Estimated gas. {@link EstimateFinalizeWithdrawalGasReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseEther } from 'viem'\n   * import { base, mainnet } from 'viem/chains'\n   * import { publicActionsL1 } from 'viem/op-stack'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(publicActionsL1())\n   *\n   * const gas = await client.estimateFinalizeWithdrawalGas({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   targetChain: optimism,\n   *   withdrawal: { ... },\n   * })\n   */\n  estimateFinalizeWithdrawalGas: <\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: EstimateFinalizeWithdrawalGasParameters<\n      chain,\n      account,\n      chainOverride\n    >,\n  ) => Promise<EstimateFinalizeWithdrawalGasReturnType>\n  /**\n   * Retrieves the first L2 output proposal that occurred after a provided block number. Used for the [Withdrawal](/op-stack/guides/withdrawals) flow.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/getL2Output\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetL2OutputParameters}\n   * @returns The L2 output. {@link GetL2OutputReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet, optimism } from 'viem/chains'\n   * import { publicActionsL1 } from 'viem/op-stack'\n   *\n   * const publicClientL1 = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(publicActionsL1())\n   *\n   * const output = await publicClientL1.getL2Output({\n   *   l2BlockNumber: 69420n,\n   *   targetChain: optimism\n   * })\n   */\n  getL2Output: <chainOverride extends Chain | undefined = undefined>(\n    parameters: GetL2OutputParameters<chain, chainOverride>,\n  ) => Promise<GetL2OutputReturnType>\n  /**\n   * Returns the time until the withdrawal transaction can be finalized. Used for the [Withdrawal](/op-stack/guides/withdrawals) flow.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/getTimeToFinalize\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetTimeToFinalizeParameters}\n   * @returns Time until finalize. {@link GetTimeToFinalizeReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { getBlockNumber } from 'viem/actions'\n   * import { mainnet, optimism } from 'viem/chains'\n   * import { publicActionsL1 } from 'viem/op-stack'\n   *\n   * const publicClientL1 = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(publicActionsL1())\n   * const publicClientL2 = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await publicClientL2.getTransactionReceipt({\n   *   hash: '0x9a2f4283636ddeb9ac32382961b22c177c9e86dd3b283735c154f897b1a7ff4a',\n   * })\n   *\n   * const [withdrawal] = getWithdrawals(receipt)\n   *\n   * const { seconds } = await publicClientL1.getTimeToFinalize({\n   *   withdrawalHash: withdrawal.withdrawalHash,\n   *   targetChain: optimism\n   * })\n   */\n  getTimeToFinalize: <chainOverride extends Chain | undefined = undefined>(\n    parameters: GetTimeToFinalizeParameters<chain, chainOverride>,\n  ) => Promise<GetTimeToFinalizeReturnType>\n  /**\n   * Returns the time until the next L2 output (after a provided block number) is submitted. Used for the [Withdrawal](/op-stack/guides/withdrawals) flow.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/getTimeToNextL2Output\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetTimeToNextL2OutputParameters}\n   * @returns The L2 transaction hash. {@link GetTimeToNextL2OutputReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet, optimism } from 'viem/chains'\n   * import { publicActionsL1 } from 'viem/op-stack'\n   *\n   * const publicClientL1 = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(publicActionsL1())\n   * const publicClientL2 = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * })\n   *\n   * const l2BlockNumber = await publicClientL2.getBlockNumber()\n   * const { seconds } = await publicClientL1.getTimeToNextL2Output({\n   *   l2BlockNumber,\n   *   targetChain: optimism\n   * })\n   */\n  getTimeToNextL2Output: <chainOverride extends Chain | undefined = undefined>(\n    parameters: GetTimeToNextL2OutputParameters<chain, chainOverride>,\n  ) => Promise<GetTimeToNextL2OutputReturnType>\n  /**\n   * Returns the time until the withdrawal transaction can be finalized. Used for the [Withdrawal](/op-stack/guides/withdrawals) flow.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/getTimeToFinalize\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetTimeToFinalizeParameters}\n   * @returns Time until finalize. {@link GetTimeToFinalizeReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { getBlockNumber } from 'viem/actions'\n   * import { mainnet, optimism } from 'viem/chains'\n   * import { publicActionsL1 } from 'viem/op-stack'\n   *\n   * const publicClientL1 = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(publicActionsL1())\n   * const publicClientL2 = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await publicClientL2.getTransactionReceipt({\n   *   hash: '0x9a2f4283636ddeb9ac32382961b22c177c9e86dd3b283735c154f897b1a7ff4a',\n   * })\n   *\n   * const [withdrawal] = getWithdrawals(receipt)\n   *\n   * const { seconds } = await publicClientL1.getTimeToFinalize({\n   *   withdrawalHash: withdrawal.withdrawalHash,\n   *   targetChain: optimism\n   * })\n   */\n  getTimeToProve: <chainOverride extends Chain | undefined = undefined>(\n    parameters: GetTimeToProveParameters<chain, chainOverride>,\n  ) => Promise<GetTimeToProveReturnType>\n  /**\n   * Returns the current status of a withdrawal. Used for the [Withdrawal](/op-stack/guides/withdrawals) flow.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/getWithdrawalStatus\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetWithdrawalStatusParameters}\n   * @returns Status of the withdrawal. {@link GetWithdrawalStatusReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { getBlockNumber } from 'viem/actions'\n   * import { mainnet, optimism } from 'viem/chains'\n   * import { publicActionsL1 } from 'viem/op-stack'\n   *\n   * const publicClientL1 = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(publicActionsL1())\n   * const publicClientL2 = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await publicClientL2.getTransactionReceipt({ hash: '0x...' })\n   * const status = await publicClientL1.getWithdrawalStatus({\n   *   receipt,\n   *   targetChain: optimism\n   * })\n   */\n  getWithdrawalStatus: <chainOverride extends Chain | undefined = undefined>(\n    parameters: GetWithdrawalStatusParameters<chain, chainOverride>,\n  ) => Promise<GetWithdrawalStatusReturnType>\n  /**\n   * Waits for the next L2 output (after the provided block number) to be submitted.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/waitForNextL2Output\n   *\n   * @param client - Client to use\n   * @param parameters - {@link WaitForNextL2OutputParameters}\n   * @returns The L2 transaction hash. {@link WaitForNextL2OutputReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet, optimism } from 'viem/chains'\n   * import { publicActionsL1 } from 'viem/op-stack'\n   *\n   * const publicClientL1 = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(publicActionsL1())\n   * const publicClientL2 = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * })\n   *\n   * const l2BlockNumber = await getBlockNumber(publicClientL2)\n   * await waitForNextL2Output(publicClientL1, {\n   *   l2BlockNumber,\n   *   targetChain: optimism\n   * })\n   */\n  waitForNextL2Output: <chainOverride extends Chain | undefined = undefined>(\n    parameters: WaitForNextL2OutputParameters<chain, chainOverride>,\n  ) => Promise<WaitForNextL2OutputReturnType>\n  /**\n   * Waits until the withdrawal transaction can be finalized. Used for the [Withdrawal](/op-stack/guides/withdrawals) flow.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/waitToFinalize\n   *\n   * @param client - Client to use\n   * @param parameters - {@link WaitToFinalizeParameters}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { getBlockNumber } from 'viem/actions'\n   * import { mainnet, optimism } from 'viem/chains'\n   * import { publicActionsL1 } from 'viem/op-stack'\n   *\n   * const publicClientL1 = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(publicActionsL1)\n   * const publicClientL2 = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await publicClientL2.getTransactionReceipt({\n   *   hash: '0x9a2f4283636ddeb9ac32382961b22c177c9e86dd3b283735c154f897b1a7ff4a',\n   * })\n   *\n   * const [withdrawal] = getWithdrawals(receipt)\n   *\n   * await publicClientL1.waitToFinalize({\n   *   withdrawalHash: withdrawal.withdrawalHash,\n   *   targetChain: optimism\n   * })\n   */\n  waitToFinalize: <chainOverride extends Chain | undefined = undefined>(\n    parameters: WaitToFinalizeParameters<chain, chainOverride>,\n  ) => Promise<WaitToFinalizeReturnType>\n  /**\n   * Waits until the L2 withdrawal transaction is provable. Used for the [Withdrawal](/op-stack/guides/withdrawals) flow.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/waitToProve\n   *\n   * @param client - Client to use\n   * @param parameters - {@link WaitToProveParameters}\n   * @returns The L2 output and withdrawal message. {@link WaitToProveReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { getBlockNumber } from 'viem/actions'\n   * import { mainnet, optimism } from 'viem/chains'\n   * import { publicActionsL1 } from 'viem/op-stack'\n   *\n   * const publicClientL1 = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(publicActionsL1)\n   * const publicClientL2 = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await publicClientL2.getTransactionReceipt({ hash: '0x...' })\n   * await publicClientL1.waitToProve({\n   *   receipt,\n   *   targetChain: optimism\n   * })\n   */\n  waitToProve: <chainOverride extends Chain | undefined = undefined>(\n    parameters: WaitToProveParameters<chain, chainOverride>,\n  ) => Promise<WaitToProveReturnType>\n}\n\n/**\n * A suite of Public Actions for suited for development with Layer 2 (OP Stack) chains.\n *\n * - Docs: https://viem.sh/op-stack/client\n *\n * @example\n * import { publicActionsL1 } from 'viem/op-stack'\n * import { mainnet } from 'viem/chains'\n * import { buildDepositTransaction } from 'viem/wallet'\n *\n * export const opStackPublicClientL1 = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * }).extend(publicActionsL1())\n */\nexport function publicActionsL1() {\n  return <\n    TTransport extends Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined,\n  >(\n    client: Client<TTransport, TChain, TAccount>,\n  ): PublicActionsL1<TChain, TAccount> => {\n    return {\n      buildInitiateWithdrawal: (args) => buildInitiateWithdrawal(client, args),\n      estimateDepositTransactionGas: (args) =>\n        estimateDepositTransactionGas(client, args),\n      estimateFinalizeWithdrawalGas: (args) =>\n        estimateFinalizeWithdrawalGas(client, args),\n      estimateProveWithdrawalGas: (args) =>\n        estimateProveWithdrawalGas(client, args),\n      getL2Output: (args) => getL2Output(client, args),\n      getTimeToFinalize: (args) => getTimeToFinalize(client, args),\n      getTimeToNextL2Output: (args) => getTimeToNextL2Output(client, args),\n      getTimeToProve: (args) => getTimeToProve(client, args),\n      getWithdrawalStatus: (args) => getWithdrawalStatus(client, args),\n      waitForNextL2Output: (args) => waitForNextL2Output(client, args),\n      waitToFinalize: (args) => waitToFinalize(client, args),\n      waitToProve: (args) => waitToProve(client, args),\n    }\n  }\n}\n", "import type { Abi, Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Account } from '../../../types/account.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../../types/contract.js'\nimport {\n  type BuildDepositTransactionParameters,\n  type BuildDepositTransactionReturnType,\n  buildDepositTransaction,\n} from '../actions/buildDepositTransaction.js'\nimport {\n  type BuildProveWithdrawalParameters,\n  type BuildProveWithdrawalReturnType,\n  buildProveWithdrawal,\n} from '../actions/buildProveWithdrawal.js'\nimport {\n  type EstimateContractL1FeeParameters,\n  type EstimateContractL1FeeReturnType,\n  estimateContractL1Fee,\n} from '../actions/estimateContractL1Fee.js'\nimport {\n  type EstimateContractL1GasParameters,\n  type EstimateContractL1GasReturnType,\n  estimateContractL1Gas,\n} from '../actions/estimateContractL1Gas.js'\nimport {\n  type EstimateContractTotalFeeParameters,\n  type EstimateContractTotalFeeReturnType,\n  estimateContractTotalFee,\n} from '../actions/estimateContractTotalFee.js'\nimport {\n  type EstimateContractTotalGasParameters,\n  type EstimateContractTotalGasReturnType,\n  estimateContractTotalGas,\n} from '../actions/estimateContractTotalGas.js'\nimport {\n  type EstimateInitiateWithdrawalGasParameters,\n  type EstimateInitiateWithdrawalGasReturnType,\n  estimateInitiateWithdrawalGas,\n} from '../actions/estimateInitiateWithdrawalGas.js'\nimport {\n  type EstimateL1FeeParameters,\n  type EstimateL1FeeReturnType,\n  estimateL1Fee,\n} from '../actions/estimateL1Fee.js'\nimport {\n  type EstimateL1GasParameters,\n  type EstimateL1GasReturnType,\n  estimateL1Gas,\n} from '../actions/estimateL1Gas.js'\nimport {\n  type EstimateTotalFeeParameters,\n  type EstimateTotalFeeReturnType,\n  estimateTotalFee,\n} from '../actions/estimateTotalFee.js'\nimport {\n  type EstimateTotalGasParameters,\n  type EstimateTotalGasReturnType,\n  estimateTotalGas,\n} from '../actions/estimateTotalGas.js'\nimport {\n  type GetL1BaseFeeParameters,\n  type GetL1BaseFeeReturnType,\n  getL1BaseFee,\n} from '../actions/getL1BaseFee.js'\n\nexport type PublicActionsL2<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> = {\n  /**\n   * Prepares parameters for a [deposit transaction](https://github.com/ethereum-optimism/optimism/blob/develop/specs/deposits.md) to be initiated on an L1.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/buildDepositTransaction\n   *\n   * @param client - Client to use\n   * @param parameters - {@link BuildDepositTransactionParameters}\n   * @returns Parameters for `depositTransaction`. {@link DepositTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, http, parseEther } from 'viem'\n   * import { base } from 'viem/chains'\n   * import { publicActionsL2 } from 'viem/op-stack'\n   *\n   * const client = createWalletClient({\n   *   chain: base,\n   *   transport: http(),\n   * }).extend(publicActionsL2())\n   *\n   * const args = await client.buildDepositTransaction({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: parseEther('1'),\n   * })\n   */\n  buildDepositTransaction: <\n    chainOverride extends Chain | undefined = undefined,\n    accountOverride extends Account | Address | undefined = undefined,\n  >(\n    parameters: BuildDepositTransactionParameters<\n      chain,\n      account,\n      chainOverride,\n      accountOverride\n    >,\n  ) => Promise<BuildDepositTransactionReturnType<account, accountOverride>>\n  /**\n   * Builds the transaction that proves a withdrawal was initiated on an L2. Used in the Withdrawal flow.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/buildProveWithdrawal\n   *\n   * @param client - Client to use\n   * @param parameters - {@link BuildProveWithdrawalParameters}\n   * @returns The prove withdraw transaction request. {@link BuildProveWithdrawalReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { optimism } from 'viem/chains'\n   * import { publicActionsL2 } from 'viem/op-stack'\n   *\n   * const publicClientL2 = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * }).extend(publicActionsL2())\n   *\n   * const args = await publicClientL2.buildProveWithdrawal({\n   *   output: { ... },\n   *   withdrawal: { ... },\n   * })\n   */\n  buildProveWithdrawal: <\n    chainOverride extends Chain | undefined = undefined,\n    accountOverride extends Account | Address | undefined = undefined,\n  >(\n    parameters: BuildProveWithdrawalParameters<\n      chain,\n      account,\n      chainOverride,\n      accountOverride\n    >,\n  ) => Promise<\n    BuildProveWithdrawalReturnType<\n      chain,\n      account,\n      chainOverride,\n      accountOverride\n    >\n  >\n  /**\n   * Estimates the L1 data fee required to execute an L2 contract write.\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateContractL1FeeParameters}\n   * @returns The gas estimate (in wei). {@link EstimateContractL1FeeReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { optimism } from 'viem/chains'\n   * import { publicActionsL2 } from 'viem/op-stack'\n   *\n   * const client = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * }).extend(publicActionsL2())\n   *\n   * const l1Fee = await client.estimateContractL1Fee({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint() public']),\n   *   functionName: 'mint',\n   *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n   * })\n   */\n  estimateContractL1Fee: <\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n    args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: EstimateContractL1FeeParameters<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride\n    >,\n  ) => Promise<EstimateContractL1FeeReturnType>\n  /**\n   * Estimates the L1 data gas required to successfully execute a contract write function call.\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateContractL1GasParameters}\n   * @returns The gas estimate (in wei). {@link EstimateContractL1GasReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { optimism } from 'viem/chains'\n   * import { publicActionsL2 } from 'viem/op-stack'\n   *\n   * const client = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * }).extend(publicActionsL2())\n   *\n   * const l1Gas = await client.estimateContractL1Gas({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint() public']),\n   *   functionName: 'mint',\n   *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n   * })\n   */\n  estimateContractL1Gas: <\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n    args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: EstimateContractL1GasParameters<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride\n    >,\n  ) => Promise<EstimateContractL1GasReturnType>\n  /**\n   * Estimates the L1 + L2 fee to execute an L2 contract write.\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateContractTotalFeeParameters}\n   * @returns The gas estimate (in wei). {@link EstimateContractTotalFeeReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { optimism } from 'viem/chains'\n   * import { publicActionsL2 } from 'viem/op-stack'\n   *\n   * const client = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * }).extend(publicActionsL2())\n   *\n   * const totalFee = await client.estimateContractTotalFee({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint() public']),\n   *   functionName: 'mint',\n   *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n   * })\n   */\n  estimateContractTotalFee: <\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n    args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: EstimateContractTotalFeeParameters<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride\n    >,\n  ) => Promise<EstimateContractTotalFeeReturnType>\n  /**\n   * Estimates the L1 data gas + L2 gas required to successfully execute a contract write function call.\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateContractTotalGasParameters}\n   * @returns The gas estimate (in wei). {@link EstimateContractTotalGasReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { optimism } from 'viem/chains'\n   * import { publicActionsL2 } from 'viem/op-stack'\n   *\n   * const client = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * }).extend(publicActionsL2())\n   *\n   * const totalGas = await client.estimateContractTotalGas({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint() public']),\n   *   functionName: 'mint',\n   *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n   * })\n   */\n  estimateContractTotalGas: <\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n    args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: EstimateContractTotalGasParameters<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride\n    >,\n  ) => Promise<EstimateContractTotalGasReturnType>\n  /**\n   * Estimates gas required to initiate a [withdrawal](https://community.optimism.io/docs/protocol/withdrawal-flow/#withdrawal-initiating-transaction) on an L2 to the L1.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/estimateInitiateWithdrawalGas\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateInitiateWithdrawalGasParameters}\n   * @returns The gas required. {@link EstimateInitiateWithdrawalGasReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseEther } from 'viem'\n   * import { base, mainnet } from 'viem/chains'\n   * import { publicActionsL2 } from 'viem/op-stack'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(publicActionsL2())\n   *\n   * const hash = await client.estimateInitiateWithdrawalGas({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   request: {\n   *     gas: 21_000n,\n   *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *     value: parseEther('1'),\n   *   },\n   * })\n   */\n  estimateInitiateWithdrawalGas: <\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: EstimateInitiateWithdrawalGasParameters<\n      chain,\n      account,\n      chainOverride\n    >,\n  ) => Promise<EstimateInitiateWithdrawalGasReturnType>\n  /**\n   * Estimates the L1 data fee required to execute an L2 transaction.\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateL1FeeParameters}\n   * @returns The fee (in wei). {@link EstimateL1FeeReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseEther } from 'viem'\n   * import { optimism } from 'viem/chains'\n   * import { publicActionsL2 } from 'viem/op-stack'\n   *\n   * const client = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * }).extend(publicActionsL2())\n   *\n   * const l1Fee = await client.estimateL1Fee({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: parseEther('1'),\n   * })\n   */\n  estimateL1Fee: <chainOverride extends Chain | undefined = undefined>(\n    parameters: EstimateL1FeeParameters<chain, account, chainOverride>,\n  ) => Promise<EstimateL1FeeReturnType>\n\n  /**\n   * Get the L1 basefee\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetL1BaseFeeParameters}\n   * @returns The fee (in wei). {@link GetL1BaseFeeReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseEther } from 'viem'\n   * import { optimism } from 'viem/chains'\n   * import { publicActionsL2 } from 'viem/op-stack'\n   *\n   * const client = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * }).extend(publicActionsL2())\n   *\n   * const l1BaseFee = await client.getL1BaseFee()\n   */\n  getL1BaseFee: <chainOverride extends Chain | undefined = undefined>(\n    parameters?: GetL1BaseFeeParameters<chain, chainOverride>,\n  ) => Promise<GetL1BaseFeeReturnType>\n  /**\n   * Estimates the amount of L1 data gas required to execute an L2 transaction.\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateL1GasParameters}\n   * @returns The gas estimate. {@link EstimateL1GasReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseEther } from 'viem'\n   * import { optimism } from 'viem/chains'\n   * import { publicActionsL2 } from 'viem/op-stack'\n   *\n   * const client = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * }).extend(publicActionsL2())\n   *\n   * const l1Gas = await client.estimateL1Gas({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: parseEther('1'),\n   * })\n   */\n  estimateL1Gas: <chainOverride extends Chain | undefined = undefined>(\n    parameters: EstimateL1GasParameters<chain, account, chainOverride>,\n  ) => Promise<EstimateL1GasReturnType>\n  /**\n   * Estimates the L1 data fee + L2 fee to execute an L2 transaction.\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateTotalFeeParameters}\n   * @returns The gas estimate. {@link EstimateTotalFeeReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseEther } from 'viem'\n   * import { optimism } from 'viem/chains'\n   * import { publicActionsL2 } from 'viem/op-stack'\n   *\n   * const client = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * }).extend(publicActionsL2())\n   *\n   * const totalFee = await client.estimateTotalFee({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: parseEther('1'),\n   * })\n   */\n  estimateTotalFee: <chainOverride extends Chain | undefined = undefined>(\n    parameters: EstimateTotalFeeParameters<chain, account, chainOverride>,\n  ) => Promise<EstimateTotalFeeReturnType>\n  /**\n   * Estimates the total amount of combined L1 data gas + L2 gas required to execute an L2 transaction.\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateTotalGasParameters}\n   * @returns The gas estimate. {@link EstimateTotalGasReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseEther } from 'viem'\n   * import { optimism } from 'viem/chains'\n   * import { publicActionsL2 } from 'viem/op-stack'\n   *\n   * const client = createPublicClient({\n   *   chain: optimism,\n   *   transport: http(),\n   * }).extend(publicActionsL2())\n   *\n   * const totalGas = await client.estimateTotalGas({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: parseEther('1'),\n   * })\n   */\n  estimateTotalGas: <chainOverride extends Chain | undefined = undefined>(\n    parameters: EstimateTotalGasParameters<chain, account, chainOverride>,\n  ) => Promise<EstimateTotalGasReturnType>\n}\n\n/**\n * A suite of Public Actions for suited for development with Layer 2 (OP Stack) chains.\n *\n * - Docs: https://viem.sh/op-stack/client\n *\n * @example\n * import { publicActionsL2 } from 'viem/op-stack'\n * import { optimism } from 'viem/chains'\n * import { buildDepositTransaction } from 'viem/wallet'\n *\n * export const opStackPublicClientL1 = createWalletClient({\n *   chain: optimism,\n *   transport: http(),\n * }).extend(publicActionsL1())\n */\nexport function publicActionsL2() {\n  return <\n    TTransport extends Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined,\n  >(\n    client: Client<TTransport, TChain, TAccount>,\n  ): PublicActionsL2<TChain, TAccount> => {\n    return {\n      buildDepositTransaction: (args) => buildDepositTransaction(client, args),\n      buildProveWithdrawal: (args) => buildProveWithdrawal(client, args),\n      estimateContractL1Fee: (args) => estimateContractL1Fee(client, args),\n      estimateContractL1Gas: (args) => estimateContractL1Gas(client, args),\n      estimateContractTotalFee: (args) =>\n        estimateContractTotalFee(client, args),\n      estimateContractTotalGas: (args) =>\n        estimateContractTotalGas(client, args),\n      estimateInitiateWithdrawalGas: (args) =>\n        estimateInitiateWithdrawalGas(client, args),\n      estimateL1Fee: (args) => estimateL1Fee(client, args),\n      getL1BaseFee: (args) => getL1BaseFee(client, args),\n      estimateL1Gas: (args) => estimateL1Gas(client, args),\n      estimateTotalFee: (args) => estimateTotalFee(client, args),\n      estimateTotalGas: (args) => estimateTotalGas(client, args),\n    }\n  }\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Account } from '../../../types/account.js'\nimport type { Chain } from '../../../types/chain.js'\nimport {\n  type DepositTransactionParameters,\n  type DepositTransactionReturnType,\n  depositTransaction,\n} from '../actions/depositTransaction.js'\nimport {\n  type FinalizeWithdrawalParameters,\n  type FinalizeWithdrawalReturnType,\n  finalizeWithdrawal,\n} from '../actions/finalizeWithdrawal.js'\nimport {\n  type ProveWithdrawalParameters,\n  type ProveWithdrawalReturnType,\n  proveWithdrawal,\n} from '../actions/proveWithdrawal.js'\n\nexport type WalletActionsL1<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> = {\n  /**\n   * Initiates a [deposit transaction](https://github.com/ethereum-optimism/optimism/blob/develop/specs/deposits.md) on an L1, which executes a transaction on L2.\n   *\n   * Internally performs a contract write to the [`depositTransaction` function](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L1/OptimismPortal.sol#L378)\n   * on the [Optimism Portal contract](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L1/OptimismPortal.sol).\n   *\n   * - Docs: https://viem.sh/op-stack/actions/depositTransaction\n   *\n   * @param client - Client to use\n   * @param parameters - {@link DepositTransactionParameters}\n   * @returns The L1 transaction hash. {@link DepositTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom, parseEther } from 'viem'\n   * import { base, mainnet } from 'viem/chains'\n   * import { walletActionsL1 } from 'viem/op-stack'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(walletActionsL1())\n   *\n   * const hash = await client.depositTransaction({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   request: {\n   *     gas: 21_000n,\n   *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *     value: parseEther('1'),\n   *   },\n   *   targetChain: base,\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { base, mainnet } from 'viem/chains'\n   * import { walletActionsL1 } from 'viem/op-stack'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(walletActionsL1())\n   *\n   * const hash = await client.depositTransaction({\n   *   request: {\n   *     gas: 21_000n,\n   *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *     value: parseEther('1'),\n   *   },\n   *   targetChain: base,\n   * })\n   */\n  depositTransaction: <chainOverride extends Chain | undefined = undefined>(\n    parameters: DepositTransactionParameters<chain, account, chainOverride>,\n  ) => Promise<DepositTransactionReturnType>\n  /**\n   * Finalizes a withdrawal that occurred on an L2. Used in the Withdrawal flow.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/finalizeWithdrawal\n   *\n   * @param client - Client to use\n   * @param parameters - {@link FinalizeWithdrawalParameters}\n   * @returns The finalize transaction hash. {@link FinalizeWithdrawalReturnType}\n   *\n   * @example\n   * import { createWalletClient, http } from 'viem'\n   * import { mainnet, optimism } from 'viem/chains'\n   * import { walletActionsL1 } from 'viem/op-stack'\n   *\n   * const walletClientL1 = createWalletClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(walletActionsL1)\n   *\n   * const hash = await walletClientL1.finalizeWithdrawal({\n   *   targetChain: optimism,\n   *   withdrawal: { ... },\n   * })\n   */\n  finalizeWithdrawal: <chainOverride extends Chain | undefined = undefined>(\n    parameters: FinalizeWithdrawalParameters<chain, account, chainOverride>,\n  ) => Promise<FinalizeWithdrawalReturnType>\n  /**\n   * Proves a withdrawal that occurred on an L2. Used in the Withdrawal flow.\n   *\n   * - Docs: https://viem.sh/op-stack/actions/proveWithdrawal\n   *\n   * @param client - Client to use\n   * @param parameters - {@link ProveWithdrawalParameters}\n   * @returns The prove transaction hash. {@link ProveWithdrawalReturnType}\n   *\n   * @example\n   * import { createWalletClient, http } from 'viem'\n   * import { mainnet, optimism } from 'viem/chains'\n   * import { walletActionsL1 } from 'viem/op-stack'\n   *\n   * const walletClientL1 = createWalletClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(walletActionsL1())\n   *\n   * const hash = await walletClientL1.proveWithdrawal({\n   *   l2OutputIndex: 4529n,\n   *   outputRootProof: { ... },\n   *   targetChain: optimism,\n   *   withdrawalProof: [ ... ],\n   *   withdrawalTransaction: { ... },\n   * })\n   */\n  proveWithdrawal: <chainOverride extends Chain | undefined = undefined>(\n    parameters: ProveWithdrawalParameters<chain, account, chainOverride>,\n  ) => Promise<ProveWithdrawalReturnType>\n}\n\n/**\n * A suite of Wallet Actions for suited for development with Layer 2 (OP Stack) chains.\n *\n * - Docs: https://viem.sh/op-stack/client\n *\n * @example\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { walletActionsL1 } from 'viem/op-stack'\n *\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * }).extend(walletActionsL1())\n *\n * const hash = await walletClient.depositTransaction({...})\n */\nexport function walletActionsL1() {\n  return <\n    TTransport extends Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined,\n  >(\n    client: Client<TTransport, TChain, TAccount>,\n  ): WalletActionsL1<TChain, TAccount> => {\n    return {\n      depositTransaction: (args) => depositTransaction(client, args),\n      finalizeWithdrawal: (args) => finalizeWithdrawal(client, args),\n      proveWithdrawal: (args) => proveWithdrawal(client, args),\n    }\n  }\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Account } from '../../../types/account.js'\nimport type { Chain } from '../../../types/chain.js'\nimport {\n  type InitiateWithdrawalParameters,\n  type InitiateWithdrawalReturnType,\n  initiateWithdrawal,\n} from '../actions/initiateWithdrawal.js'\n\nexport type WalletActionsL2<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> = {\n  /**\n   * Initiates a [withdrawal](https://community.optimism.io/docs/protocol/withdrawal-flow/#withdrawal-initiating-transaction) on an L2 to the L1.\n   *\n   * Internally performs a contract write to the [`initiateWithdrawal` function](https://github.com/ethereum-optimism/optimism/blob/283f0aa2e3358ced30ff7cbd4028c0c0c3faa140/packages/contracts-bedrock/src/L2/L2ToL1MessagePasser.sol#L73)\n   * on the [Optimism L2ToL1MessagePasser predeploy contract](https://github.com/ethereum-optimism/optimism/blob/283f0aa2e3358ced30ff7cbd4028c0c0c3faa140/packages/contracts-bedrock/src/L2/L2ToL1MessagePasser.sol).\n   *\n   * - Docs: https://viem.sh/op-stack/actions/initiateWithdrawal\n   *\n   * @param client - Client to use\n   * @param parameters - {@link InitiateWithdrawalParameters}\n   * @returns The L2 transaction hash. {@link InitiateWithdrawalReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom, parseEther } from 'viem'\n   * import { base, mainnet } from 'viem/chains'\n   * import { walletActionsL2 } from 'viem/op-stack'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(walletActionsL2())\n   *\n   * const hash = await client.initiateWithdrawal({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   args: {\n   *     gas: 21_000n,\n   *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *     value: parseEther('1'),\n   *   },\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { base, mainnet } from 'viem/chains'\n   * import { walletActionsL2 } from 'viem/op-stack'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(walletActionsL2())\n   *\n   * const hash = await client.initiateWithdrawal({\n   *   args: {\n   *     gas: 21_000n,\n   *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *     value: parseEther('1'),\n   *   },\n   * })\n   */\n  initiateWithdrawal: <chainOverride extends Chain | undefined = undefined>(\n    parameters: InitiateWithdrawalParameters<chain, account, chainOverride>,\n  ) => Promise<InitiateWithdrawalReturnType>\n}\n\n/**\n * A suite of Wallet Actions for suited for development with Layer 2 (OP Stack) chains.\n *\n * - Docs: https://viem.sh/op-stack/client\n *\n * @example\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { walletActionsL1 } from 'viem/op-stack'\n *\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * }).extend(walletActionsL1())\n *\n * const hash = await walletClient.depositTransaction({...})\n */\nexport function walletActionsL2() {\n  return <\n    TTransport extends Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined,\n  >(\n    client: Client<TTransport, TChain, TAccount>,\n  ): WalletActionsL2<TChain, TAccount> => {\n    return {\n      initiateWithdrawal: (args) => initiateWithdrawal(client, args),\n    }\n  }\n}\n", "import { InvalidSerializedTransactionError } from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { isHex } from '../../utils/data/isHex.js'\nimport { sliceHex } from '../../utils/data/slice.js'\nimport { hexToBigInt, hexToBool } from '../../utils/encoding/fromHex.js'\nimport type { GetSerializedTransactionType } from '../../utils/transaction/getSerializedTransactionType.js'\nimport {\n  type ParseTransactionErrorType as ParseTransactionErrorType_,\n  type ParseTransactionReturnType as ParseTransactionReturnType_,\n  parseTransaction as parseTransaction_,\n  toTransactionArray,\n} from '../../utils/transaction/parseTransaction.js'\nimport { assertTransactionDeposit } from './serializers.js'\nimport type {\n  OpStackTransactionSerialized,\n  OpStackTransactionType,\n  TransactionSerializableDeposit,\n  TransactionSerializedDeposit,\n} from './types/transaction.js'\n\nexport type ParseTransactionReturnType<\n  TSerialized extends\n    OpStackTransactionSerialized = OpStackTransactionSerialized,\n  TType extends\n    OpStackTransactionType = GetSerializedTransactionType<TSerialized>,\n> = TSerialized extends TransactionSerializedDeposit\n  ? TransactionSerializableDeposit\n  : ParseTransactionReturnType_<TSerialized, TType>\n\nexport type ParseTransactionErrorType = ParseTransactionErrorType_ | ErrorType\n\nexport function parseTransaction<\n  TSerialized extends OpStackTransactionSerialized,\n>(serializedTransaction: TSerialized): ParseTransactionReturnType<TSerialized> {\n  const serializedType = sliceHex(serializedTransaction, 0, 1)\n\n  if (serializedType === '0x7e')\n    return parseTransactionDeposit(\n      serializedTransaction as TransactionSerializedDeposit,\n    ) as ParseTransactionReturnType<TSerialized>\n\n  return parseTransaction_(\n    serializedTransaction,\n  ) as ParseTransactionReturnType<TSerialized>\n}\n\nfunction parseTransactionDeposit(\n  serializedTransaction: TransactionSerializedDeposit,\n): ParseTransactionReturnType<TransactionSerializedDeposit> {\n  const transactionArray = toTransactionArray(serializedTransaction)\n\n  const [sourceHash, from, to, mint, value, gas, isSystemTx, data] =\n    transactionArray\n\n  if (transactionArray.length !== 8 || !isHex(sourceHash) || !isHex(from))\n    throw new InvalidSerializedTransactionError({\n      attributes: {\n        sourceHash,\n        from,\n        gas,\n        to,\n        mint,\n        value,\n        isSystemTx,\n        data,\n      },\n      serializedTransaction,\n      type: 'deposit',\n    })\n\n  const transaction: TransactionSerializableDeposit = {\n    sourceHash,\n    from,\n    type: 'deposit',\n  }\n\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)\n  if (isHex(to) && to !== '0x') transaction.to = to\n  if (isHex(mint) && mint !== '0x') transaction.mint = hexToBigInt(mint)\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)\n  if (isHex(isSystemTx) && isSystemTx !== '0x')\n    transaction.isSystemTx = hexToBool(isSystemTx)\n  if (isHex(data) && data !== '0x') transaction.data = data\n\n  assertTransactionDeposit(transaction)\n\n  return transaction\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport type { Log } from '../../../types/log.js'\nimport {\n  type ParseEventLogsErrorType,\n  parseEventLogs,\n} from '../../../utils/abi/parseEventLogs.js'\nimport { portalAbi } from '../abis.js'\n\nexport type ExtractTransactionDepositedLogsParameters = {\n  /** An opaque array of logs. */\n  logs: Log[]\n}\n\nexport type ExtractTransactionDepositedLogsReturnType = Log<\n  bigint,\n  number,\n  false,\n  undefined,\n  true,\n  typeof portalAbi,\n  'TransactionDeposited'\n>[]\n\nexport type ExtractTransactionDepositedLogsErrorType =\n  | ParseEventLogsErrorType\n  | ErrorType\n\nexport function extractTransactionDepositedLogs({\n  logs,\n}: ExtractTransactionDepositedLogsParameters) {\n  return parseEventLogs({\n    abi: portalAbi,\n    eventName: 'TransactionDeposited',\n    logs,\n  })\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { type SizeErrorType, size } from '../../../utils/data/size.js'\nimport { type SliceErrorType, slice } from '../../../utils/data/slice.js'\nimport { hexToBigInt } from '../../../utils/encoding/fromHex.js'\n\nexport type OpaqueDataToDepositDataParameters = Hex\n\nexport type OpaqueDataToDepositDataReturnType = {\n  mint: bigint\n  value: bigint\n  gas: bigint\n  isCreation: boolean\n  data: Hex\n}\n\nexport type OpaqueDataToDepositDataErrorType =\n  | SliceErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function opaqueDataToDepositData(\n  opaqueData: Hex,\n): OpaqueDataToDepositDataReturnType {\n  let offset = 0\n  const mint = slice(opaqueData, offset, offset + 32)\n  offset += 32\n  const value = slice(opaqueData, offset, offset + 32)\n  offset += 32\n  const gas = slice(opaqueData, offset, offset + 8)\n  offset += 8\n  const isCreation = BigInt(slice(opaqueData, offset, offset + 1)) === 1n\n  offset += 1\n  const data =\n    offset > size(opaqueData) - 1\n      ? '0x'\n      : slice(opaqueData, offset, opaqueData.length)\n  return {\n    mint: hexToBigInt(mint),\n    value: hexToBigInt(value),\n    gas: hexToBigInt(gas),\n    isCreation,\n    data,\n  }\n}\n", "// Adapted from https://github.com/ethereum-optimism/optimism/blob/develop/packages/core-utils/src/optimism/deposit-transaction.ts#L117\n\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../../../utils/data/concat.js'\nimport { type PadErrorType, pad } from '../../../utils/data/pad.js'\nimport { type ToHexErrorType, toHex } from '../../../utils/encoding/toHex.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../../utils/hash/keccak256.js'\n\nexport type GetSourceHashParameters = {\n  /** The L1 block hash. */\n  l1BlockHash: Hex\n} & (\n  | {\n      /** Domain of source hash. */\n      domain: 'userDeposit'\n      /** The index of the log on the L1. */\n      l1LogIndex: number\n      /** The sequence number. */\n      sequenceNumber?: undefined\n    }\n  | {\n      /** Domain of source hash. */\n      domain: 'l1InfoDeposit'\n      /** The index of the log on the L1. */\n      l1LogIndex?: undefined\n      /** The sequence number. */\n      sequenceNumber: number\n    }\n)\n\nexport type GetSourceHashReturnType = Hex\n\nexport type GetSourceHashErrorType =\n  | ConcatErrorType\n  | Keccak256ErrorType\n  | PadErrorType\n  | ToHexErrorType\n  | ErrorType\n\nconst sourceHashDomainMap = {\n  userDeposit: 0,\n  l1InfoDeposit: 1,\n} as const\n\nexport function getSourceHash({\n  domain,\n  l1LogIndex,\n  l1BlockHash,\n  sequenceNumber,\n}: GetSourceHashParameters) {\n  const marker = toHex(l1LogIndex! || sequenceNumber!)\n  const input = concat([l1BlockHash, pad(marker, { size: 32 })])\n  const depositIdHash = keccak256(input)\n  const domainHex = toHex(sourceHashDomainMap[domain])\n  const domainInput = concat([pad(domainHex, { size: 32 }), depositIdHash])\n  return keccak256(domainInput)\n}\n", "// Adapted from https://github.com/ethereum-optimism/optimism/blob/develop/packages/core-utils/src/optimism/deposit-transaction.ts#L117\n\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Log } from '../../../types/log.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { keccak256 } from '../../../utils/hash/keccak256.js'\nimport type { portalAbi } from '../abis.js'\nimport { serializeTransaction } from '../serializers.js'\nimport { getSourceHash } from './getSourceHash.js'\nimport { opaqueDataToDepositData } from './opaqueDataToDepositData.js'\n\nexport type GetL2TransactionHashParameters = {\n  /** The \"TransactionDeposited\" log to compute the L2 hash from. */\n  log: Log<\n    bigint,\n    number,\n    false,\n    undefined,\n    true,\n    typeof portalAbi,\n    'TransactionDeposited'\n  >\n}\n\nexport type GetL2TransactionHashReturnType = Hex\n\nexport type GetL2TransactionHashErrorType = ErrorType\n\nexport function getL2TransactionHash({ log }: GetL2TransactionHashParameters) {\n  const sourceHash = getSourceHash({\n    domain: 'userDeposit',\n    l1BlockHash: log.blockHash,\n    l1LogIndex: log.logIndex,\n  })\n  const { data, gas, isCreation, mint, value } = opaqueDataToDepositData(\n    log.args.opaqueData,\n  )\n\n  return keccak256(\n    serializeTransaction({\n      from: log.args.from,\n      to: isCreation ? undefined : log.args.to,\n      sourceHash,\n      data,\n      gas,\n      isSystemTx: false,\n      mint,\n      type: 'deposit',\n      value,\n    }),\n  )\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport type { Log } from '../../../types/log.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { extractTransactionDepositedLogs } from './extractTransactionDepositedLogs.js'\nimport { getL2TransactionHash } from './getL2TransactionHash.js'\n\nexport type GetL2TransactionHashesParameters = {\n  /** The L1 transaction receipt logs. */\n  logs: Log[]\n}\n\nexport type GetL2TransactionHashesReturnType = Hex[]\n\nexport type GetL2TransactionHashesErrorType = ErrorType\n\nexport function getL2TransactionHashes({\n  logs,\n}: GetL2TransactionHashesParameters): GetL2TransactionHashesReturnType {\n  const extractedLogs = extractTransactionDepositedLogs({ logs })\n  return extractedLogs.map((log) => getL2TransactionHash({ log }))\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0GA,eAAsB,wBAMpB,QACA,MAKC;AAED,QAAM,EACJ,SAAS,UACT,QAAQ,OAAO,OACf,KACA,MACA,YACA,MACA,IACA,MAAK,IACH;AAEJ,QAAM,UAAU,WAAW,aAAa,QAAQ,IAAI;AAEpD,QAAM,UAAU,MAAM,0BAA0B,QAAQ;IACtD,SAAS,OAAO,SAAY;IAC5B;IACA;IACA;IACA,YAAY,CAAC,KAAK;IAClB;IACA;GACsC;AAExC,SAAO;IACL;IACA,SAAS;MACP,MAAM,QAAQ;MACd,KAAK,QAAQ;MACb;MACA;MACA,IAAI,QAAQ;MACZ,OAAO,QAAQ;;IAEjB,aAAa;;AAEjB;;;AC3EA,eAAsB,wBAMpB,QACA,MAKC;AAED,QAAM,EAAE,SAAS,UAAU,QAAQ,OAAO,OAAO,KAAK,MAAM,IAAI,MAAK,IAAK;AAE1E,QAAM,UAAU,WAAW,aAAa,QAAQ,IAAI;AAEpD,QAAM,UAAU,MAAM,0BAA0B,QAAQ;IACtD;IACA;IACA;IACA;IACA,YAAY,CAAC,KAAK;IAClB;IACA;GACsC;AAExC,SAAO;IACL;IACA,SAAS;MACP,MAAM,QAAQ;MACd,KAAK,QAAQ;MACb,IAAI,QAAQ;MACZ,OAAO,QAAQ;;;AAGrB;;;ACjGM,SAAU,6BAA6B,EAC3C,eAAc,GACyB;AACvC,QAAM,OAAO,oBACX,CAAC,EAAE,MAAM,UAAS,GAAI,EAAE,MAAM,UAAS,CAAE,GACzC,CAAC,gBAAgB,EAAE,CAAC;AAEtB,SAAO,UAAU,IAAI;AACvB;;;ACQA,IAAM,yBACJ;AAiEF,eAAsB,qBAMpB,QACA,MAKC;AAID,QAAM,EAAE,SAAS,QAAQ,OAAO,OAAO,QAAQ,WAAU,IAAK;AAC9D,QAAM,EAAE,eAAc,IAAK;AAC3B,QAAM,EAAE,cAAa,IAAK;AAE1B,QAAM,OAAO,6BAA6B,EAAE,eAAc,CAAE;AAC5D,QAAM,CAAC,OAAO,KAAK,IAAI,MAAM,QAAQ,IAAI;IACvC,SAAS,QAAQ;MACf,SAAS,UAAU,oBAAoB;MACvC,aAAa,CAAC,IAAI;MAClB,aAAa;KACd;IACD,SAAS,QAAQ;MACf,aAAa;KACd;GACF;AAED,SAAO;IACL;IACA,eAAe,OAAO;IACtB,iBAAiB;MACf,iBAAiB,MAAM;MACvB,0BAA0B,MAAM;MAChC,WAAW,MAAM;MACjB,SAAS;;IAEX,aAAa;IACb,iBAAiB,kBACf,UAAU,IAAI,GACd,MAAM,aAAa,CAAC,EAAE,KAAK;IAE7B;;AAOJ;AAEM,SAAU,kBAAkB,KAAa,OAAqB;AAClE,QAAM,eAAe,MAAM,MAAM,SAAS,CAAC;AAC3C,QAAM,YAAY,QAAQ,YAAY;AACtC,MAAI,UAAU,WAAW;AAAI,WAAO;AAEpC,QAAM,gBAAgB,CAAC,GAAG,KAAK;AAC/B,aAAW,QAAQ,WAAW;AAE5B,QAAI,CAAC,MAAM,QAAQ,IAAI;AAAG;AAQ1B,UAAM,SAAS,KAAK,CAAC,EAAE,MAAM,CAAC;AAC9B,QAAI,OAAO,WAAW,YAAY,CAAC,IAAI,SAAS,MAAM;AAAG;AACzD,kBAAc,KAAK,MAAM,IAAI,CAAC;EAChC;AACA,SAAO;AACT;;;AC9KO,IAAM,oBAAoB;EAC/B,EAAE,QAAQ,CAAA,GAAI,iBAAiB,cAAc,MAAM,cAAa;EAChE;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAC,EAAE,cAAc,SAAS,MAAM,SAAS,MAAM,QAAO,CAAE;IAChE,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAC,EAAE,cAAc,SAAS,MAAM,SAAS,MAAM,QAAO,CAAE;IAChE,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,UAAU,MAAM,IAAI,MAAM,SAAQ,CAAE;IAC9D,iBAAiB;IACjB,MAAM;;;AAIH,IAAM,oBAAoB;EAC/B;IACE,QAAQ;MACN,EAAE,cAAc,WAAW,MAAM,uBAAuB,MAAM,UAAS;MACvE,EAAE,cAAc,WAAW,MAAM,gBAAgB,MAAM,UAAS;MAChE;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER,EAAE,cAAc,WAAW,MAAM,sBAAsB,MAAM,UAAS;MACtE,EAAE,cAAc,WAAW,MAAM,aAAa,MAAM,UAAS;MAC7D,EAAE,cAAc,WAAW,MAAM,eAAe,MAAM,UAAS;MAC/D;QACE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN,EAAE,SAAS,OAAO,cAAc,SAAS,MAAM,WAAW,MAAM,QAAO;;IAEzE,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN,EAAE,cAAc,WAAW,MAAM,kBAAkB,MAAM,UAAS;;IAEpE,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN,EAAE,cAAc,WAAW,MAAM,kBAAkB,MAAM,UAAS;;IAEpE,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN,EAAE,cAAc,WAAW,MAAM,kBAAkB,MAAM,UAAS;;IAEpE,MAAM;IACN,SAAS;MACP;QACE,YAAY;UACV,EAAE,cAAc,WAAW,MAAM,cAAc,MAAM,UAAS;UAC9D,EAAE,cAAc,WAAW,MAAM,aAAa,MAAM,UAAS;UAC7D,EAAE,cAAc,WAAW,MAAM,iBAAiB,MAAM,UAAS;;QAEnE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN,EAAE,cAAc,WAAW,MAAM,kBAAkB,MAAM,UAAS;;IAEpE,MAAM;IACN,SAAS;MACP;QACE,YAAY;UACV,EAAE,cAAc,WAAW,MAAM,cAAc,MAAM,UAAS;UAC9D,EAAE,cAAc,WAAW,MAAM,aAAa,MAAM,UAAS;UAC7D,EAAE,cAAc,WAAW,MAAM,iBAAiB,MAAM,UAAS;;QAEnE,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN,EAAE,cAAc,WAAW,MAAM,kBAAkB,MAAM,UAAS;;IAEpE,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN;QACE,cAAc;QACd,MAAM;QACN,MAAM;;MAER,EAAE,cAAc,WAAW,MAAM,sBAAsB,MAAM,UAAS;;IAExE,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN,EAAE,cAAc,WAAW,MAAM,eAAe,MAAM,UAAS;MAC/D,EAAE,cAAc,WAAW,MAAM,kBAAkB,MAAM,UAAS;MAClE,EAAE,cAAc,WAAW,MAAM,gBAAgB,MAAM,UAAS;MAChE,EAAE,cAAc,WAAW,MAAM,kBAAkB,MAAM,UAAS;;IAEpE,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,UAAU,MAAM,IAAI,MAAM,SAAQ,CAAE;IAC9D,iBAAiB;IACjB,MAAM;;;AA8cH,IAAM,yBAAyB;EACpC,EAAE,QAAQ,CAAA,GAAI,iBAAiB,cAAc,MAAM,cAAa;EAChE;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;MAER,EAAE,SAAS,OAAO,cAAc,SAAS,MAAM,QAAQ,MAAM,QAAO;MACpE;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,WAAW;IACX,QAAQ;MACN;QACE,SAAS;QACT,cAAc;QACd,MAAM;QACN,MAAM;;;IAGV,MAAM;IACN,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,UAAU,MAAM,IAAI,MAAM,SAAQ,CAAE;IAC9D,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ;MACN,EAAE,cAAc,WAAW,MAAM,WAAW,MAAM,UAAS;MAC3D,EAAE,cAAc,WAAW,MAAM,aAAa,MAAM,UAAS;MAC7D,EAAE,cAAc,SAAS,MAAM,SAAS,MAAM,QAAO;;IAEvD,MAAM;IACN,SAAS,CAAA;IACT,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAChE,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAC,EAAE,cAAc,WAAW,MAAM,IAAI,MAAM,UAAS,CAAE;IAC/D,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,QAAQ,MAAM,IAAI,MAAM,OAAM,CAAE;IAC1D,iBAAiB;IACjB,MAAM;;EAER;IACE,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,cAAc,UAAU,MAAM,IAAI,MAAM,SAAQ,CAAE;IAC9D,iBAAiB;IACjB,MAAM;;EAER,EAAE,iBAAiB,WAAW,MAAM,UAAS;;AAGxC,IAAM,YAAY;EACvB,EAAE,iBAAiB,cAAc,MAAM,eAAe,QAAQ,CAAA,EAAE;EAChE;IACE,MAAM;IACN,WAAW;IACX,QAAQ;MACN,EAAE,MAAM,WAAW,cAAc,SAAS,MAAM,SAAS,SAAS,MAAK;;IAEzE,MAAM;;EAER;IACE,MAAM;IACN,WAAW;IACX,QAAQ;MACN;QACE,MAAM;QACN,cAAc;QACd,MAAM;QACN,SAAS;;;IAGb,MAAM;;EAER;IACE,MAAM;IACN,WAAW;IACX,QAAQ;MACN,EAAE,MAAM,QAAQ,cAAc,WAAW,MAAM,WAAW,SAAS,KAAI;MACvE,EAAE,MAAM,MAAM,cAAc,WAAW,MAAM,WAAW,SAAS,KAAI;MACrE;QACE,MAAM;QACN,cAAc;QACd,MAAM;QACN,SAAS;;MAEX;QACE,MAAM;QACN,cAAc;QACd,MAAM;QACN,SAAS;;;IAGb,MAAM;;EAER;IACE,MAAM;IACN,WAAW;IACX,QAAQ;MACN;QACE,MAAM;QACN,cAAc;QACd,MAAM;QACN,SAAS;;;IAGb,MAAM;;EAER;IACE,MAAM;IACN,WAAW;IACX,QAAQ;MACN;QACE,MAAM;QACN,cAAc;QACd,MAAM;QACN,SAAS;;MAEX,EAAE,MAAM,WAAW,cAAc,QAAQ,MAAM,QAAQ,SAAS,MAAK;;IAEvE,MAAM;;EAER;IACE,MAAM;IACN,WAAW;IACX,QAAQ;MACN;QACE,MAAM;QACN,cAAc;QACd,MAAM;QACN,SAAS;;MAEX,EAAE,MAAM,QAAQ,cAAc,WAAW,MAAM,WAAW,SAAS,KAAI;MACvE,EAAE,MAAM,MAAM,cAAc,WAAW,MAAM,WAAW,SAAS,KAAI;;IAEvE,MAAM;;EAER;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,MAAM,IAAI,cAAc,WAAW,MAAM,UAAS,CAAE;;EAElE;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP,EAAE,MAAM,IAAI,cAAc,2BAA2B,MAAM,UAAS;;;EAGxE;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP,EAAE,MAAM,IAAI,cAAc,yBAAyB,MAAM,UAAS;;;EAGtE;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ;MACN,EAAE,MAAM,OAAO,cAAc,WAAW,MAAM,UAAS;MACvD,EAAE,MAAM,UAAU,cAAc,WAAW,MAAM,UAAS;MAC1D,EAAE,MAAM,aAAa,cAAc,UAAU,MAAM,SAAQ;MAC3D,EAAE,MAAM,eAAe,cAAc,QAAQ,MAAM,OAAM;MACzD,EAAE,MAAM,SAAS,cAAc,SAAS,MAAM,QAAO;;IAEvD,MAAM;IACN,SAAS,CAAA;;EAEX;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;;EAEX;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ;MACN;QACE,MAAM;QACN,cAAc;QACd,MAAM;QACN,YAAY;UACV,EAAE,MAAM,SAAS,cAAc,WAAW,MAAM,UAAS;UACzD,EAAE,MAAM,UAAU,cAAc,WAAW,MAAM,UAAS;UAC1D,EAAE,MAAM,UAAU,cAAc,WAAW,MAAM,UAAS;UAC1D,EAAE,MAAM,SAAS,cAAc,WAAW,MAAM,UAAS;UACzD,EAAE,MAAM,YAAY,cAAc,WAAW,MAAM,UAAS;UAC5D,EAAE,MAAM,QAAQ,cAAc,SAAS,MAAM,QAAO;;;;IAI1D,MAAM;IACN,SAAS,CAAA;;EAEX;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAC,EAAE,MAAM,IAAI,cAAc,WAAW,MAAM,UAAS,CAAE;IAC/D,MAAM;IACN,SAAS,CAAC,EAAE,MAAM,IAAI,cAAc,QAAQ,MAAM,OAAM,CAAE;;EAE5D;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,MAAM,IAAI,cAAc,WAAW,MAAM,UAAS,CAAE;;EAElE;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ;MACN;QACE,MAAM;QACN,cAAc;QACd,MAAM;;MAER,EAAE,MAAM,aAAa,cAAc,WAAW,MAAM,UAAS;MAC7D;QACE,MAAM;QACN,cAAc;QACd,MAAM;;MAER,EAAE,MAAM,WAAW,cAAc,QAAQ,MAAM,OAAM;;IAEvD,MAAM;IACN,SAAS,CAAA;;EAEX;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ;MACN,EAAE,MAAM,kBAAkB,cAAc,WAAW,MAAM,UAAS;;IAEpE,MAAM;IACN,SAAS,CAAC,EAAE,MAAM,IAAI,cAAc,QAAQ,MAAM,OAAM,CAAE;;EAE5D;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP,EAAE,MAAM,IAAI,cAAc,2BAA2B,MAAM,UAAS;;;EAGxE;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,MAAM,IAAI,cAAc,WAAW,MAAM,UAAS,CAAE;;EAElE;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAC,EAAE,MAAM,cAAc,cAAc,UAAU,MAAM,SAAQ,CAAE;IACvE,MAAM;IACN,SAAS,CAAC,EAAE,MAAM,IAAI,cAAc,UAAU,MAAM,SAAQ,CAAE;;EAEhE;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP,EAAE,MAAM,eAAe,cAAc,WAAW,MAAM,UAAS;MAC/D,EAAE,MAAM,iBAAiB,cAAc,UAAU,MAAM,SAAQ;MAC/D,EAAE,MAAM,gBAAgB,cAAc,UAAU,MAAM,SAAQ;;;EAGlE;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;;EAEX;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,MAAM,IAAI,cAAc,QAAQ,MAAM,OAAM,CAAE;;EAE5D;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ;MACN;QACE,MAAM;QACN,cAAc;QACd,MAAM;QACN,YAAY;UACV,EAAE,MAAM,SAAS,cAAc,WAAW,MAAM,UAAS;UACzD,EAAE,MAAM,UAAU,cAAc,WAAW,MAAM,UAAS;UAC1D,EAAE,MAAM,UAAU,cAAc,WAAW,MAAM,UAAS;UAC1D,EAAE,MAAM,SAAS,cAAc,WAAW,MAAM,UAAS;UACzD,EAAE,MAAM,YAAY,cAAc,WAAW,MAAM,UAAS;UAC5D,EAAE,MAAM,QAAQ,cAAc,SAAS,MAAM,QAAO;;;MAGxD,EAAE,MAAM,kBAAkB,cAAc,WAAW,MAAM,UAAS;MAClE;QACE,MAAM;QACN,cAAc;QACd,MAAM;QACN,YAAY;UACV,EAAE,MAAM,WAAW,cAAc,WAAW,MAAM,UAAS;UAC3D,EAAE,MAAM,aAAa,cAAc,WAAW,MAAM,UAAS;UAC7D;YACE,MAAM;YACN,cAAc;YACd,MAAM;;UAER,EAAE,MAAM,mBAAmB,cAAc,WAAW,MAAM,UAAS;;;MAGvE,EAAE,MAAM,oBAAoB,cAAc,WAAW,MAAM,UAAS;;IAEtE,MAAM;IACN,SAAS,CAAA;;EAEX;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAC,EAAE,MAAM,IAAI,cAAc,WAAW,MAAM,UAAS,CAAE;IAC/D,MAAM;IACN,SAAS;MACP,EAAE,MAAM,cAAc,cAAc,WAAW,MAAM,UAAS;MAC9D,EAAE,MAAM,aAAa,cAAc,WAAW,MAAM,UAAS;MAC7D,EAAE,MAAM,iBAAiB,cAAc,WAAW,MAAM,UAAS;;;EAGrE;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAA;IACR,MAAM;IACN,SAAS;MACP,EAAE,MAAM,IAAI,cAAc,yBAAyB,MAAM,UAAS;;;EAGtE;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAA;;EAEX;IACE,iBAAiB;IACjB,MAAM;IACN,QAAQ,CAAA;IACR,MAAM;IACN,SAAS,CAAC,EAAE,MAAM,IAAI,cAAc,UAAU,MAAM,SAAQ,CAAE;;EAEhE,EAAE,iBAAiB,WAAW,MAAM,UAAS;;;;AChnC/C,eAAsB,8BAKpB,QACA,YAIC;AAED,QAAM,EACJ,SACA,QAAQ,OAAO,OACf,KACA,cACA,sBACA,OACA,SAAS,EACP,OAAO,MACP,KAAK,OACL,aAAa,OACb,MACA,KAAK,MACL,MAAK,GAEP,YAAW,IACT;AAEJ,QAAM,iBAAiB,MAAK;AAC1B,QAAI,WAAW;AAAe,aAAO,WAAW;AAChD,QAAI;AAAO,aAAO,YAAa,UAAU,OAAO,MAAM,EAAE,EAAE;AAC1D,WAAO,OAAO,OAAO,YAAa,UAAU,MAAM,EAAE,CAAC,EAAE;EACzD,GAAE;AAEF,SAAO,oBAAoB,QAAQ;IACjC;IACA,KAAK;IACL,SAAS;IACT;IACA,cAAc;IACd,MAAM;MACJ,aAAa,cAAc;MAC3B,SAAS,QAAQ;MACjB;MACA;MACA;;IAEF;IACA;IACA;IACA;IACA,OAAO;GACyB;AACpC;;;ACpBA,eAAsB,mBAKpB,QACA,YAAuE;AAEvE,QAAM,EACJ,SACA,QAAQ,OAAO,OACf,KACA,cACA,sBACA,OACA,SAAS,EACP,OAAO,MACP,KAAK,OACL,aAAa,OACb,MACA,KAAK,MACL,MAAK,GAEP,YAAW,IACT;AAEJ,QAAM,iBAAiB,MAAK;AAC1B,QAAI,WAAW;AAAe,aAAO,WAAW;AAChD,QAAI;AAAO,aAAO,YAAa,UAAU,OAAO,MAAM,EAAE,EAAE;AAC1D,WAAO,OAAO,OAAO,YAAa,UAAU,MAAM,EAAE,CAAC,EAAE;EACzD,GAAE;AAEF,QAAM,OACJ,OAAO,QAAQ,YAAY,QAAQ,OAC/B,MAAM,8BACJ,QACA,UAAqD,IAEvD;AAEN,SAAO,cAAc,QAAQ;IAC3B;IACA,KAAK;IACL,SAAS;IACT;IACA,cAAc;IACd,MAAM;MACJ,aAAa,cAAc;MAC3B,SAAS,QAAQ;MACjB;MACA;MACA;;IAEF;IACA;IACA;IACA,OAAO;IACP,KAAK;GACmC;AAC5C;;;ACjGA,eAAsB,cAKpB,QACA,MAA+D;AAE/D,QAAM,EACJ,QAAQ,OAAO,OACf,uBAAuB,uBAAsB,IAC3C;AAEJ,QAAM,yBAAyB,MAAK;AAClC,QAAI;AAAwB,aAAO;AACnC,QAAI;AACF,aAAO,wBAAwB;QAC7B;QACA,UAAU;OACX;AACH,WAAO,UAAU,eAAe;EAClC,GAAE;AAGF,QAAM,UAAU,MAAM,0BACpB,QACA,IAA2C;AAG7C,gBAAc,OAAkC;AAEhD,QAAM,cAAc,qBAAqB;IACvC,GAAG;IACH,MAAM;GACoB;AAE5B,SAAO,aAAa,QAAQ;IAC1B,KAAK;IACL,SAAS;IACT,cAAc;IACd,MAAM,CAAC,WAAkB;GAC1B;AACH;;;ACvBA,eAAsB,sBAQpB,QACA,YAOC;AAED,QAAM,EAAE,KAAK,SAAS,MAAM,cAAc,GAAG,QAAO,IAClD;AACF,QAAM,OAAO,mBAAmB;IAC9B;IACA;IACA;GAC+B;AACjC,MAAI;AACF,UAAM,MAAM,MAAM,cAAc,QAAQ;MACtC;MACA,IAAI;MACJ,GAAG;KACkC;AACvC,WAAO;EACT,SAAS,OAAO;AACd,UAAM,UAAU,QAAQ,UAAU,aAAa,QAAQ,OAAO,IAAI;AAClE,UAAM,iBAAiB,OAAoB;MACzC;MACA;MACA;MACA,UAAU;MACV;MACA,QAAQ,mCAAS;KAClB;EACH;AACF;;;AC9DA,eAAsB,cAKpB,QACA,MAA+D;AAE/D,QAAM,EACJ,QAAQ,OAAO,OACf,uBAAuB,uBAAsB,IAC3C;AAEJ,QAAM,yBAAyB,MAAK;AAClC,QAAI;AAAwB,aAAO;AACnC,QAAI;AACF,aAAO,wBAAwB;QAC7B;QACA,UAAU;OACX;AACH,WAAO,UAAU,eAAe;EAClC,GAAE;AAGF,QAAM,UAAU,MAAM,0BACpB,QACA,IAA2C;AAG7C,gBAAc,OAAkC;AAEhD,QAAM,cAAc,qBAAqB;IACvC,GAAG;IACH,MAAM;GACoB;AAE5B,SAAO,aAAa,QAAQ;IAC1B,KAAK;IACL,SAAS;IACT,cAAc;IACd,MAAM,CAAC,WAAkB;GAC1B;AACH;;;ACvBA,eAAsB,sBAQpB,QACA,YAOC;AAED,QAAM,EAAE,KAAK,SAAS,MAAM,cAAc,GAAG,QAAO,IAClD;AACF,QAAM,OAAO,mBAAmB;IAC9B;IACA;IACA;GAC+B;AACjC,MAAI;AACF,UAAM,MAAM,MAAM,cAAc,QAAQ;MACtC;MACA,IAAI;MACJ,GAAG;KACkC;AACvC,WAAO;EACT,SAAS,OAAO;AACd,UAAM,UAAU,QAAQ,UAAU,aAAa,QAAQ,OAAO,IAAI;AAClE,UAAM,iBAAiB,OAAoB;MACzC;MACA;MACA;MACA,UAAU;MACV;MACA,QAAQ,mCAAS;KAClB;EACH;AACF;;;AC7EA,eAAsB,iBAKpB,QACA,MAAkE;AAGlE,QAAM,UAAU,MAAM,0BACpB,QACA,IAA2C;AAG7C,QAAM,CAAC,OAAO,OAAO,UAAU,IAAI,MAAM,QAAQ,IAAI;IACnD,cAAc,QAAQ,OAAkC;IACxD,YAAY,QAAQ,OAAgC;IACpD,YAAY,MAAM;GACnB;AAED,SAAO,QAAQ,QAAQ;AACzB;;;ACeA,eAAsB,yBAQpB,QACA,YAOC;AAED,QAAM,EAAE,KAAK,SAAS,MAAM,cAAc,GAAG,QAAO,IAClD;AACF,QAAM,OAAO,mBAAmB;IAC9B;IACA;IACA;GAC+B;AACjC,MAAI;AACF,UAAM,MAAM,MAAM,iBAAiB,QAAQ;MACzC;MACA,IAAI;MACJ,GAAG;KACqC;AAC1C,WAAO;EACT,SAAS,OAAO;AACd,UAAM,UAAU,QAAQ,UAAU,aAAa,QAAQ,OAAO,IAAI;AAClE,UAAM,iBAAiB,OAAoB;MACzC;MACA;MACA;MACA,UAAU;MACV;MACA,QAAQ,mCAAS;KAClB;EACH;AACF;;;ACpFA,eAAsB,iBAKpB,QACA,MAAkE;AAGlE,QAAM,UAAU,MAAM,0BACpB,QACA,IAA2C;AAG7C,QAAM,CAAC,OAAO,KAAK,IAAI,MAAM,QAAQ,IAAI;IACvC,cAAc,QAAQ,OAAkC;IACxD,YAAY,QAAQ,OAAgC;GACrD;AAED,SAAO,QAAQ;AACjB;;;ACqBA,eAAsB,yBAQpB,QACA,YAOC;AAED,QAAM,EAAE,KAAK,SAAS,MAAM,cAAc,GAAG,QAAO,IAClD;AACF,QAAM,OAAO,mBAAmB;IAC9B;IACA;IACA;GAC+B;AACjC,MAAI;AACF,UAAM,MAAM,MAAM,iBAAiB,QAAQ;MACzC;MACA,IAAI;MACJ,GAAG;KACqC;AAC1C,WAAO;EACT,SAAS,OAAO;AACd,UAAM,UAAU,QAAQ,UAAU,aAAa,QAAQ,OAAO,IAAI;AAClE,UAAM,iBAAiB,OAAoB;MACzC;MACA;MACA;MACA,UAAU;MACV;MACA,QAAQ,mCAAS;KAClB;EACH;AACF;;;AC1FA,eAAsB,aAIpB,QACA,MAAqD;AAErD,QAAM,EACJ,QAAQ,OAAO,OACf,uBAAuB,uBAAsB,IAC3C,QAAQ,CAAA;AAEZ,QAAM,yBAAyB,MAAK;AAClC,QAAI;AAAwB,aAAO;AACnC,QAAI;AACF,aAAO,wBAAwB;QAC7B;QACA,UAAU;OACX;AACH,WAAO,UAAU,eAAe;EAClC,GAAE;AAEF,SAAO,aAAa,QAAQ;IAC1B,KAAK;IACL,SAAS;IACT,cAAc;GACf;AACH;;;ACJA,eAAsB,8BAKpB,QACA,YAIC;AAED,QAAM,EACJ,SACA,QAAQ,OAAO,OACf,KACA,cACA,sBACA,OACA,aACA,WAAU,IACR;AAEJ,QAAM,iBAAiB,MAAK;AAC1B,QAAI,WAAW;AAAe,aAAO,WAAW;AAChD,QAAI;AAAO,aAAO,YAAa,UAAU,OAAO,MAAM,EAAE,EAAE;AAC1D,WAAO,OAAO,OAAO,YAAa,UAAU,MAAM,EAAE,CAAC,EAAE;EACzD,GAAE;AAEF,SAAO,oBAAoB,QAAQ;IACjC;IACA,KAAK;IACL,SAAS;IACT;IACA,cAAc;IACd,MAAM,CAAC,UAAU;IACjB;IACA;IACA;IACA;GACgC;AACpC;;;AChCA,eAAsB,mBAKpB,QACA,YAAuE;AAEvE,QAAM,EACJ,SACA,QAAQ,OAAO,OACf,KACA,cACA,sBACA,OACA,aACA,WAAU,IACR;AAEJ,QAAM,iBAAiB,MAAK;AAC1B,QAAI,WAAW;AAAe,aAAO,WAAW;AAChD,QAAI;AAAO,aAAO,YAAa,UAAU,OAAO,MAAM,EAAE,EAAE;AAC1D,WAAO,OAAO,OAAO,YAAa,UAAU,MAAM,EAAE,CAAC,EAAE;EACzD,GAAE;AAEF,QAAM,OACJ,OAAO,QAAQ,YAAY,QAAQ,OAC/B,MAAM,8BACJ,QACA,UAAqD,IAEvD;AAEN,SAAO,cAAc,QAAQ;IAC3B;IACA,KAAK;IACL,SAAS;IACT;IACA,cAAc;IACd,MAAM,CAAC,UAAU;IACjB,KAAK;IACL;IACA;IACA;GACwC;AAC5C;;;ACzEA,eAAsB,YAKpB,QACA,YAAuD;AAEvD,QAAM,EAAE,QAAQ,OAAO,OAAO,eAAe,YAAW,IAAK;AAE7D,QAAM,yBAAyB,MAAK;AAClC,QAAI,WAAW;AACb,aAAO,WAAW;AACpB,QAAI;AAAO,aAAO,YAAa,UAAU,eAAe,MAAM,EAAE,EAAE;AAClE,WAAO,OAAO,OAAO,YAAa,UAAU,cAAc,EAAE,CAAC,EAAE;EACjE,GAAE;AAEF,QAAM,cAAc,MAAM,aAAa,QAAQ;IAC7C,SAAS;IACT,KAAK;IACL,cAAc;IACd,MAAM,CAAC,aAAa;GACrB;AACD,QAAM,SAAS,MAAM,aAAa,QAAQ;IACxC,SAAS;IACT,KAAK;IACL,cAAc;IACd,MAAM,CAAC,WAAW;GACnB;AAED,SAAO,EAAE,aAAa,GAAG,OAAM;AACjC;;;ACrDA,IAAM,SAAS;AAqCf,eAAsB,kBAKpB,QACA,YAA6D;AAE7D,QAAM,EAAE,QAAQ,OAAO,OAAO,gBAAgB,YAAW,IAAK;AAE9D,QAAM,yBAAyB,MAAK;AAClC,QAAI,WAAW;AACb,aAAO,WAAW;AACpB,QAAI;AAAO,aAAO,YAAa,UAAU,eAAe,MAAM,EAAE,EAAE;AAClE,WAAO,OAAO,OAAO,YAAa,UAAU,cAAc,EAAE,CAAC,EAAE;EACjE,GAAE;AACF,QAAM,iBAAiB,MAAK;AAC1B,QAAI,WAAW;AAAe,aAAO,WAAW;AAChD,QAAI;AAAO,aAAO,YAAa,UAAU,OAAO,MAAM,EAAE,EAAE;AAC1D,WAAO,OAAO,OAAO,YAAa,UAAU,MAAM,EAAE,CAAC,EAAE;EACzD,GAAE;AAEF,QAAM,CAAC,CAAC,aAAa,gBAAgB,cAAc,GAAG,MAAM,IAC1D,MAAM,UAAU,QAAQ;IACtB,cAAc;IACd,WAAW;MACT;QACE,KAAK;QACL,SAAS;QACT,cAAc;QACd,MAAM,CAAC,cAAc;;MAEvB;QACE,KAAK;QACL,SAAS;QACT,cAAc;;;GAGnB;AAEH,QAAM,qBAAqB,KAAK,IAAG,IAAK,MAAO,OAAO,cAAc;AACpE,QAAM,oBAAoB,OAAO,MAAM,IAAI;AAE3C,QAAM,UAAU,KAAK,MACnB,oBAAoB,IAAI,IAAI,oBAAoB,MAAM;AAExD,QAAM,YAAY,KAAK,IAAG,IAAK,UAAU;AAEzC,SAAO,EAAE,QAAQ,OAAO,MAAM,GAAG,SAAS,UAAS;AACrD;;;ACzCA,eAAsB,sBAKpB,QACA,YAAiE;AAEjE,QAAM,EACJ,iBAAiB,KACjB,QAAQ,OAAO,OACf,eACA,YAAW,IACT;AAEJ,QAAM,yBAAyB,MAAK;AAClC,QAAI,WAAW;AACb,aAAO,WAAW;AACpB,QAAI;AAAO,aAAO,YAAa,UAAU,eAAe,MAAM,EAAE,EAAE;AAClE,WAAO,OAAO,OAAO,YAAa,UAAU,cAAc,EAAE,CAAC,EAAE;EACjE,GAAE;AAEF,QAAM,CAAC,mBAAmB,WAAW,aAAa,IAAI,MAAM,UAC1D,QACA;IACE,cAAc;IACd,WAAW;MACT;QACE,KAAK;QACL,SAAS;QACT,cAAc;;MAEhB;QACE,KAAK;QACL,SAAS;QACT,cAAc;;MAEhB;QACE,KAAK;QACL,SAAS;QACT,cAAc;;;GAGnB;AAEH,QAAM,eAAe,MAAM,aAAa,QAAQ;IAC9C,KAAK;IACL,SAAS;IACT,cAAc;IACd,MAAM,CAAC,iBAAiB;GACzB;AACD,QAAM,wBAAwB,OAAO,aAAa,SAAS,IAAI;AAE/D,QAAM,WAAW,OAAO,gBAAgB,SAAS;AACjD,QAAM,qBAAqB,KAAK,KAAK,WAAW,cAAc;AAE9D,QAAM,MAAM,KAAK,IAAG;AAEpB,QAAM,WAAW,MAAK;AAGpB,QAAI,MAAM;AAAuB,aAAO;AAIxC,QAAI,aAAa,gBAAgB;AAAe,aAAO;AAEvD,UAAM,gBAAgB,OAAO,gBAAgB,aAAa,aAAa;AAEvE,UAAM,UAAU,KAAK,MAAM,MAAM,yBAAyB,GAAI;AAC9D,UAAM,sBACJ,qBAAsB,UAAU;AAClC,WAAO,gBAAgB,gBACnB,sBACA,KAAK,MAAM,gBAAgB,OAAO,aAAa,CAAC,IAAI,qBAClD;EACR,GAAE;AAEF,QAAM,YAAY,UAAU,IAAI,MAAM,UAAU,MAAO;AAEvD,SAAO,EAAE,UAAU,SAAS,UAAS;AACvC;;;ACjGA,eAAsB,eAKpB,QACA,YAA0D;AAE1D,QAAM,EAAE,QAAO,IAAK;AAEpB,SAAO,sBAAsB,QAAQ;IACnC,GAAG;IACH,eAAe,QAAQ;GACxB;AACH;;;ACvEM,IAAO,oCAAP,cAAiD,UAAS;EAE9D,YAAY,EAAE,KAAI,GAAiB;AACjC,UACE,+CAA+C,IAAI,4BAA4B;AAH1E,WAAA,eAAA,MAAA,QAAA;;;;aAAO;;EAKhB;;;;ACcI,SAAU,6BAA6B,EAC3C,KAAI,GACmC;AACvC,SAAO,eAAe;IACpB,KAAK;IACL,WAAW;IACX;GACD;AACH;;;AChBM,SAAU,eAAe,EAC7B,KAAI,GACqB;AACzB,QAAM,gBAAgB,6BAA6B,EAAE,KAAI,CAAE;AAC3D,SAAO,cAAc,IAAI,CAAC,QAAQ,IAAI,IAAI;AAC5C;;;ACuDA,eAAsB,oBAKpB,QACA,YAA+D;AArFjE;AAuFE,QAAM,EAAE,QAAQ,OAAO,OAAO,SAAS,YAAW,IAAK;AAEvD,QAAM,iBAAiB,MAAK;AAC1B,QAAI,WAAW;AAAe,aAAO,WAAW;AAChD,QAAI;AAAO,aAAO,YAAa,UAAU,OAAO,MAAM,EAAE,EAAE;AAC1D,WAAO,OAAO,OAAO,YAAa,UAAU,MAAM,EAAE,CAAC,EAAE;EACzD,GAAE;AAEF,QAAM,CAAC,UAAU,IAAI,eAAe,OAAO;AAE3C,MAAI,CAAC;AACH,UAAM,IAAI,kCAAkC;MAC1C,MAAM,QAAQ;KACf;AAEH,QAAM,CAAC,cAAc,aAAa,iBAAiB,oBAAoB,IACrE,MAAM,QAAQ,WAAW;IACvB,YAAY,QAAQ;MAClB,GAAG;MACH,eAAe,QAAQ;KACxB;IACD,aAAa,QAAQ;MACnB,KAAK;MACL,SAAS;MACT,cAAc;MACd,MAAM,CAAC,WAAW,cAAc;KACjC;IACD,aAAa,QAAQ;MACnB,KAAK;MACL,SAAS;MACT,cAAc;MACd,MAAM,CAAC,WAAW,cAAc;KACjC;IACD,kBAAkB,QAAQ;MACxB,GAAG;MACH,gBAAgB,WAAW;KAC5B;GACF;AAIH,MAAI,aAAa,WAAW,YAAY;AACtC,UAAM,QAAQ,aAAa;AAC3B,QACE,MAAM,iBAAiB,mCACvB,iBAAM,MAAM,SAAZ,mBAAkB,SAAlB,mBAAyB,QACvB;AAEF,aAAO;AACT,UAAM;EACR;AACA,MAAI,YAAY,WAAW;AAAY,UAAM,YAAY;AACzD,MAAI,gBAAgB,WAAW;AAAY,UAAM,gBAAgB;AACjE,MAAI,qBAAqB,WAAW;AAClC,UAAM,qBAAqB;AAE7B,QAAM,CAAC,GAAG,cAAc,IAAI,YAAY;AACxC,MAAI,CAAC;AAAgB,WAAO;AAE5B,QAAM,YAAY,gBAAgB;AAClC,MAAI;AAAW,WAAO;AAEtB,QAAM,EAAE,QAAO,IAAK,qBAAqB;AACzC,SAAO,UAAU,IAAI,wBAAwB;AAC/C;;;ACrEA,eAAsB,8BAKpB,QACA,YAIC;AAED,QAAM,EACJ,SACA,QAAQ,OAAO,OACf,KACA,cACA,sBACA,OACA,SAAS,EAAE,OAAO,MAAM,KAAK,OAAO,IAAI,MAAK,EAAE,IAC7C;AAEJ,SAAO,oBAAoB,QAAQ;IACjC;IACA,KAAK;IACL,SAAS,UAAU,oBAAoB;IACvC;IACA,cAAc;IACd,MAAM,CAAC,IAAI,OAAO,IAAI;IACtB;IACA;IACA;IACA;IACA;GACgC;AACpC;;;ACJA,eAAsB,mBAKpB,QACA,YAAuE;AAEvE,QAAM,EACJ,SACA,QAAQ,OAAO,OACf,KACA,cACA,sBACA,OACA,SAAS,EAAE,OAAO,MAAM,KAAK,OAAO,IAAI,MAAK,EAAE,IAC7C;AAEJ,QAAM,OACJ,OAAO,QAAQ,YAAY,QAAQ,OAC/B,MAAM,8BACJ,QACA,UAAqD,IAEvD;AAEN,SAAO,cAAc,QAAQ;IAC3B;IACA,KAAK;IACL,SAAS,UAAU,oBAAoB;IACvC;IACA,cAAc;IACd,MAAM,CAAC,IAAI,OAAO,IAAI;IACtB,KAAK;IACL;IACA;IACA;IACA;GACwC;AAC5C;;;AC1DA,eAAsB,2BAKpB,QACA,YAIC;AAED,QAAM,EACJ,SACA,QAAQ,OAAO,OACf,KACA,eACA,cACA,sBACA,OACA,iBACA,aACA,iBACA,WAAU,IACR;AAEJ,QAAM,iBAAiB,MAAK;AAC1B,QAAI,WAAW;AAAe,aAAO,WAAW;AAChD,QAAI;AAAO,aAAO,YAAa,UAAU,OAAO,MAAM,EAAE,EAAE;AAC1D,WAAO,OAAO,OAAO,YAAa,UAAU,MAAM,EAAE,CAAC,EAAE;EACzD,GAAE;AAEF,SAAO,oBAAoB,QAAQ;IACjC;IACA,KAAK;IACL,SAAS;IACT;IACA,cAAc;IACd,MAAM,CAAC,YAAY,eAAe,iBAAiB,eAAe;IAClE;IACA;IACA;IACA;GACgC;AACpC;;;ACnCA,eAAsB,gBAKpB,QACA,YAAoE;AAEpE,QAAM,EACJ,SACA,QAAQ,OAAO,OACf,KACA,eACA,cACA,sBACA,OACA,iBACA,aACA,iBACA,WAAU,IACR;AAEJ,QAAM,iBAAiB,MAAK;AAC1B,QAAI,WAAW;AAAe,aAAO,WAAW;AAChD,QAAI;AAAO,aAAO,YAAa,UAAU,OAAO,MAAM,EAAE,EAAE;AAC1D,WAAO,OAAO,OAAO,YAAa,UAAU,MAAM,EAAE,CAAC,EAAE;EACzD,GAAE;AAEF,QAAM,OACJ,OAAO,QAAQ,YAAY,QAAQ,OAC/B,MAAM,2BACJ,QACA,UAAkD,IAEpD,OAAO;AAEb,SAAO,cAAc,QAAQ;IAC3B;IACA,KAAK;IACL,SAAS;IACT;IACA,cAAc;IACd,MAAM,CAAC,YAAY,eAAe,iBAAiB,eAAe;IAClE,KAAK;IACL;IACA;IACA;GACwC;AAC5C;;;AC1EA,eAAsB,oBAKpB,QACA,YAA+D;AAE/D,QAAM,EAAE,kBAAkB,OAAO,gBAAe,IAAK;AAErD,QAAM,EAAE,QAAO,IAAK,MAAM,sBAAsB,QAAQ,UAAU;AAElE,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACrC,SACE,OAAO,EAAE,OAAM,MAAM;AACnB,UAAI;AACF,cAAM,SAAS,MAAM,YAAY,QAAQ,UAAU;AACnD,eAAM;AACN,gBAAQ,MAAM;MAChB,SAAS,GAAG;AACV,cAAM,QAAQ;AACd,YAAI,EAAE,MAAM,iBAAiB,gCAAgC;AAC3D,iBAAM;AACN,iBAAO,CAAC;QACV;MACF;IACF,GACA;MACE,UAAU;MACV,iBAAiB,YAAY,UAAU;KACxC;EAEL,CAAC;AACH;;;ACzDA,eAAsB,eAKpB,QACA,YAA0D;AAE1D,QAAM,EAAE,QAAO,IAAK,MAAM,kBAAkB,QAAQ,UAAU;AAC9D,QAAM,KAAK,UAAU,GAAI;AAC3B;;;ACYA,eAAsB,YAKpB,QACA,YAAuD;AAEvD,QAAM,EAAE,QAAO,IAAK;AAEpB,QAAM,CAAC,UAAU,IAAI,eAAe,OAAO;AAE3C,MAAI,CAAC;AACH,UAAM,IAAI,kCAAkC;MAC1C,MAAM,QAAQ;KACf;AAEH,QAAM,SAAS,MAAM,oBAAoB,QAAQ;IAC/C,GAAG;IACH,eAAe,QAAQ;GACxB;AAED,SAAO,EAAE,QAAQ,WAAU;AAC7B;;;ACoZM,SAAU,kBAAe;AAC7B,SAAO,CAKL,WACqC;AACrC,WAAO;MACL,yBAAyB,CAAC,SAAS,wBAAwB,QAAQ,IAAI;MACvE,+BAA+B,CAAC,SAC9B,8BAA8B,QAAQ,IAAI;MAC5C,+BAA+B,CAAC,SAC9B,8BAA8B,QAAQ,IAAI;MAC5C,4BAA4B,CAAC,SAC3B,2BAA2B,QAAQ,IAAI;MACzC,aAAa,CAAC,SAAS,YAAY,QAAQ,IAAI;MAC/C,mBAAmB,CAAC,SAAS,kBAAkB,QAAQ,IAAI;MAC3D,uBAAuB,CAAC,SAAS,sBAAsB,QAAQ,IAAI;MACnE,gBAAgB,CAAC,SAAS,eAAe,QAAQ,IAAI;MACrD,qBAAqB,CAAC,SAAS,oBAAoB,QAAQ,IAAI;MAC/D,qBAAqB,CAAC,SAAS,oBAAoB,QAAQ,IAAI;MAC/D,gBAAgB,CAAC,SAAS,eAAe,QAAQ,IAAI;MACrD,aAAa,CAAC,SAAS,YAAY,QAAQ,IAAI;;EAEnD;AACF;;;ACvCM,SAAU,kBAAe;AAC7B,SAAO,CAKL,WACqC;AACrC,WAAO;MACL,yBAAyB,CAAC,SAAS,wBAAwB,QAAQ,IAAI;MACvE,sBAAsB,CAAC,SAAS,qBAAqB,QAAQ,IAAI;MACjE,uBAAuB,CAAC,SAAS,sBAAsB,QAAQ,IAAI;MACnE,uBAAuB,CAAC,SAAS,sBAAsB,QAAQ,IAAI;MACnE,0BAA0B,CAAC,SACzB,yBAAyB,QAAQ,IAAI;MACvC,0BAA0B,CAAC,SACzB,yBAAyB,QAAQ,IAAI;MACvC,+BAA+B,CAAC,SAC9B,8BAA8B,QAAQ,IAAI;MAC5C,eAAe,CAAC,SAAS,cAAc,QAAQ,IAAI;MACnD,cAAc,CAAC,SAAS,aAAa,QAAQ,IAAI;MACjD,eAAe,CAAC,SAAS,cAAc,QAAQ,IAAI;MACnD,kBAAkB,CAAC,SAAS,iBAAiB,QAAQ,IAAI;MACzD,kBAAkB,CAAC,SAAS,iBAAiB,QAAQ,IAAI;;EAE7D;AACF;;;ACtWM,SAAU,kBAAe;AAC7B,SAAO,CAKL,WACqC;AACrC,WAAO;MACL,oBAAoB,CAAC,SAAS,mBAAmB,QAAQ,IAAI;MAC7D,oBAAoB,CAAC,SAAS,mBAAmB,QAAQ,IAAI;MAC7D,iBAAiB,CAAC,SAAS,gBAAgB,QAAQ,IAAI;;EAE3D;AACF;;;ACnFM,SAAU,kBAAe;AAC7B,SAAO,CAKL,WACqC;AACrC,WAAO;MACL,oBAAoB,CAAC,SAAS,mBAAmB,QAAQ,IAAI;;EAEjE;AACF;;;ACrEM,SAAUA,kBAEd,uBAAkC;AAClC,QAAM,iBAAiB,SAAS,uBAAuB,GAAG,CAAC;AAE3D,MAAI,mBAAmB;AACrB,WAAO,wBACL,qBAAqD;AAGzD,SAAO,iBACL,qBAAqB;AAEzB;AAEA,SAAS,wBACP,uBAAmD;AAEnD,QAAM,mBAAmB,mBAAmB,qBAAqB;AAEjE,QAAM,CAAC,YAAY,MAAM,IAAI,MAAM,OAAO,KAAK,YAAY,IAAI,IAC7D;AAEF,MAAI,iBAAiB,WAAW,KAAK,CAAC,MAAM,UAAU,KAAK,CAAC,MAAM,IAAI;AACpE,UAAM,IAAI,kCAAkC;MAC1C,YAAY;QACV;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;MAEF;MACA,MAAM;KACP;AAEH,QAAM,cAA8C;IAClD;IACA;IACA,MAAM;;AAGR,MAAI,MAAM,GAAG,KAAK,QAAQ;AAAM,gBAAY,MAAM,YAAY,GAAG;AACjE,MAAI,MAAM,EAAE,KAAK,OAAO;AAAM,gBAAY,KAAK;AAC/C,MAAI,MAAM,IAAI,KAAK,SAAS;AAAM,gBAAY,OAAO,YAAY,IAAI;AACrE,MAAI,MAAM,KAAK,KAAK,UAAU;AAAM,gBAAY,QAAQ,YAAY,KAAK;AACzE,MAAI,MAAM,UAAU,KAAK,eAAe;AACtC,gBAAY,aAAa,UAAU,UAAU;AAC/C,MAAI,MAAM,IAAI,KAAK,SAAS;AAAM,gBAAY,OAAO;AAErD,2BAAyB,WAAW;AAEpC,SAAO;AACT;;;AC5DM,SAAU,gCAAgC,EAC9C,KAAI,GACsC;AAC1C,SAAO,eAAe;IACpB,KAAK;IACL,WAAW;IACX;GACD;AACH;;;ACdM,SAAU,wBACd,YAAe;AAEf,MAAI,SAAS;AACb,QAAM,OAAO,MAAM,YAAY,QAAQ,SAAS,EAAE;AAClD,YAAU;AACV,QAAM,QAAQ,MAAM,YAAY,QAAQ,SAAS,EAAE;AACnD,YAAU;AACV,QAAM,MAAM,MAAM,YAAY,QAAQ,SAAS,CAAC;AAChD,YAAU;AACV,QAAM,aAAa,OAAO,MAAM,YAAY,QAAQ,SAAS,CAAC,CAAC,MAAM;AACrE,YAAU;AACV,QAAM,OACJ,SAAS,KAAK,UAAU,IAAI,IACxB,OACA,MAAM,YAAY,QAAQ,WAAW,MAAM;AACjD,SAAO;IACL,MAAM,YAAY,IAAI;IACtB,OAAO,YAAY,KAAK;IACxB,KAAK,YAAY,GAAG;IACpB;IACA;;AAEJ;;;ACDA,IAAM,sBAAsB;EAC1B,aAAa;EACb,eAAe;;AAGX,SAAU,cAAc,EAC5B,QACA,YACA,aACA,eAAc,GACU;AACxB,QAAM,SAAS,MAAM,cAAe,cAAe;AACnD,QAAM,QAAQ,OAAO,CAAC,aAAa,IAAI,QAAQ,EAAE,MAAM,GAAE,CAAE,CAAC,CAAC;AAC7D,QAAM,gBAAgB,UAAU,KAAK;AACrC,QAAM,YAAY,MAAM,oBAAoB,MAAM,CAAC;AACnD,QAAM,cAAc,OAAO,CAAC,IAAI,WAAW,EAAE,MAAM,GAAE,CAAE,GAAG,aAAa,CAAC;AACxE,SAAO,UAAU,WAAW;AAC9B;;;AChCM,SAAU,qBAAqB,EAAE,IAAG,GAAkC;AAC1E,QAAM,aAAa,cAAc;IAC/B,QAAQ;IACR,aAAa,IAAI;IACjB,YAAY,IAAI;GACjB;AACD,QAAM,EAAE,MAAM,KAAK,YAAY,MAAM,MAAK,IAAK,wBAC7C,IAAI,KAAK,UAAU;AAGrB,SAAO,UACLC,sBAAqB;IACnB,MAAM,IAAI,KAAK;IACf,IAAI,aAAa,SAAY,IAAI,KAAK;IACtC;IACA;IACA;IACA,YAAY;IACZ;IACA,MAAM;IACN;GACD,CAAC;AAEN;;;ACpCM,SAAU,uBAAuB,EACrC,KAAI,GAC6B;AACjC,QAAM,gBAAgB,gCAAgC,EAAE,KAAI,CAAE;AAC9D,SAAO,cAAc,IAAI,CAAC,QAAQ,qBAAqB,EAAE,IAAG,CAAE,CAAC;AACjE;",
  "names": ["parseTransaction", "serializeTransaction"]
}
