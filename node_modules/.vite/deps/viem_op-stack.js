import {
  ancient8,
  ancient8Sepolia,
  assertTransactionDeposit,
  base,
  baseGoerli,
  baseSepolia,
  chainConfig,
  contracts,
  fraxtal,
  fraxtalTestnet,
  optimism,
  optimismGoerli,
  optimismSepolia,
  pgn,
  pgnTestnet,
  serializeTransaction as serializeTransaction2,
  serializers,
  zora,
  zoraSepolia,
  zoraTestnet
} from "./chunk-TE6KAXP6.js";
import {
  estimateContractGas,
  estimateGas,
  fromRlp,
  getBlock,
  getContractError,
  getGasPrice,
  getProof,
  multicall,
  parseEventLogs,
  parseTransaction,
  poll,
  prepareTransactionRequest,
  readContract,
  serializeTransaction,
  toRlp,
  toTransactionArray,
  wait,
  writeContract,
  zeroAddress
} from "./chunk-Y63FHTWR.js";
import "./chunk-B75VHKS6.js";
import {
  BaseError,
  ContractFunctionRevertedError,
  InvalidSerializedTransactionError,
  assertRequest,
  concat,
  encodeAbiParameters,
  encodeFunctionData,
  getChainContractAddress,
  hexToBigInt,
  hexToBool,
  isHex,
  keccak256,
  pad,
  parseAccount,
  size,
  slice,
  sliceHex,
  toHex
} from "./chunk-ZLH3PCAW.js";
import "./chunk-PWTGQGJA.js";
import "./chunk-6TJCVOLN.js";

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/buildDepositTransaction.js
async function buildDepositTransaction(client, args) {
  const { account: account_, chain = client.chain, gas, data, isCreation, mint, to, value } = args;
  const account = account_ ? parseAccount(account_) : void 0;
  const request = await prepareTransactionRequest(client, {
    account: mint ? void 0 : account,
    chain,
    gas,
    data,
    parameters: ["gas"],
    to,
    value
  });
  return {
    account,
    request: {
      data: request.data,
      gas: request.gas,
      mint,
      isCreation,
      to: request.to,
      value: request.value
    },
    targetChain: chain
  };
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/buildInitiateWithdrawal.js
async function buildInitiateWithdrawal(client, args) {
  const { account: account_, chain = client.chain, gas, data, to, value } = args;
  const account = account_ ? parseAccount(account_) : void 0;
  const request = await prepareTransactionRequest(client, {
    account,
    chain,
    gas,
    data,
    parameters: ["gas"],
    to,
    value
  });
  return {
    account,
    request: {
      data: request.data,
      gas: request.gas,
      to: request.to,
      value: request.value
    }
  };
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/utils/getWithdrawalHashStorageSlot.js
function getWithdrawalHashStorageSlot({ withdrawalHash }) {
  const data = encodeAbiParameters([{ type: "bytes32" }, { type: "uint256" }], [withdrawalHash, 0n]);
  return keccak256(data);
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/buildProveWithdrawal.js
var outputRootProofVersion = "0x0000000000000000000000000000000000000000000000000000000000000000";
async function buildProveWithdrawal(client, args) {
  const { account, chain = client.chain, output, withdrawal } = args;
  const { withdrawalHash } = withdrawal;
  const { l2BlockNumber } = output;
  const slot = getWithdrawalHashStorageSlot({ withdrawalHash });
  const [proof, block] = await Promise.all([
    getProof(client, {
      address: contracts.l2ToL1MessagePasser.address,
      storageKeys: [slot],
      blockNumber: l2BlockNumber
    }),
    getBlock(client, {
      blockNumber: l2BlockNumber
    })
  ]);
  return {
    account,
    l2OutputIndex: output.outputIndex,
    outputRootProof: {
      latestBlockhash: block.hash,
      messagePasserStorageRoot: proof.storageHash,
      stateRoot: block.stateRoot,
      version: outputRootProofVersion
    },
    targetChain: chain,
    withdrawalProof: maybeAddProofNode(keccak256(slot), proof.storageProof[0].proof),
    withdrawal
  };
}
function maybeAddProofNode(key, proof) {
  const lastProofRlp = proof[proof.length - 1];
  const lastProof = fromRlp(lastProofRlp);
  if (lastProof.length !== 17)
    return proof;
  const modifiedProof = [...proof];
  for (const item of lastProof) {
    if (!Array.isArray(item))
      continue;
    const suffix = item[0].slice(3);
    if (typeof suffix !== "string" || !key.endsWith(suffix))
      continue;
    modifiedProof.push(toRlp(item));
  }
  return modifiedProof;
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/abis.js
var gasPriceOracleAbi = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    inputs: [],
    name: "DECIMALS",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "baseFee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "gasPrice",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "_data", type: "bytes" }],
    name: "getL1Fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "_data", type: "bytes" }],
    name: "getL1GasUsed",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "l1BaseFee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "overhead",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "scalar",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  }
];
var l2OutputOracleAbi = [
  {
    inputs: [
      { internalType: "uint256", name: "_submissionInterval", type: "uint256" },
      { internalType: "uint256", name: "_l2BlockTime", type: "uint256" },
      {
        internalType: "uint256",
        name: "_startingBlockNumber",
        type: "uint256"
      },
      { internalType: "uint256", name: "_startingTimestamp", type: "uint256" },
      { internalType: "address", name: "_proposer", type: "address" },
      { internalType: "address", name: "_challenger", type: "address" },
      {
        internalType: "uint256",
        name: "_finalizationPeriodSeconds",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: "uint8", name: "version", type: "uint8" }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "outputRoot",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "l2OutputIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "l2BlockNumber",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "l1Timestamp",
        type: "uint256"
      }
    ],
    name: "OutputProposed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "prevNextOutputIndex",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "newNextOutputIndex",
        type: "uint256"
      }
    ],
    name: "OutputsDeleted",
    type: "event"
  },
  {
    inputs: [],
    name: "CHALLENGER",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FINALIZATION_PERIOD_SECONDS",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "L2_BLOCK_TIME",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PROPOSER",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "SUBMISSION_INTERVAL",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_l2BlockNumber", type: "uint256" }
    ],
    name: "computeL2Timestamp",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_l2OutputIndex", type: "uint256" }
    ],
    name: "deleteL2Outputs",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_l2OutputIndex", type: "uint256" }
    ],
    name: "getL2Output",
    outputs: [
      {
        components: [
          { internalType: "bytes32", name: "outputRoot", type: "bytes32" },
          { internalType: "uint128", name: "timestamp", type: "uint128" },
          { internalType: "uint128", name: "l2BlockNumber", type: "uint128" }
        ],
        internalType: "struct Types.OutputProposal",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_l2BlockNumber", type: "uint256" }
    ],
    name: "getL2OutputAfter",
    outputs: [
      {
        components: [
          { internalType: "bytes32", name: "outputRoot", type: "bytes32" },
          { internalType: "uint128", name: "timestamp", type: "uint128" },
          { internalType: "uint128", name: "l2BlockNumber", type: "uint128" }
        ],
        internalType: "struct Types.OutputProposal",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_l2BlockNumber", type: "uint256" }
    ],
    name: "getL2OutputIndexAfter",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_startingBlockNumber",
        type: "uint256"
      },
      { internalType: "uint256", name: "_startingTimestamp", type: "uint256" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "latestBlockNumber",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "latestOutputIndex",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "nextBlockNumber",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "nextOutputIndex",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "_outputRoot", type: "bytes32" },
      { internalType: "uint256", name: "_l2BlockNumber", type: "uint256" },
      { internalType: "bytes32", name: "_l1BlockHash", type: "bytes32" },
      { internalType: "uint256", name: "_l1BlockNumber", type: "uint256" }
    ],
    name: "proposeL2Output",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "startingBlockNumber",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "startingTimestamp",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  }
];
var l2ToL1MessagePasserAbi = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "gasLimit",
        type: "uint256"
      },
      { indexed: false, internalType: "bytes", name: "data", type: "bytes" },
      {
        indexed: false,
        internalType: "bytes32",
        name: "withdrawalHash",
        type: "bytes32"
      }
    ],
    name: "MessagePassed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "WithdrawerBalanceBurnt",
    type: "event"
  },
  {
    inputs: [],
    name: "MESSAGE_VERSION",
    outputs: [{ internalType: "uint16", name: "", type: "uint16" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "_target", type: "address" },
      { internalType: "uint256", name: "_gasLimit", type: "uint256" },
      { internalType: "bytes", name: "_data", type: "bytes" }
    ],
    name: "initiateWithdrawal",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "messageNonce",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    name: "sentMessages",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];
var portalAbi = [
  { stateMutability: "nonpayable", type: "constructor", inputs: [] },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "version", internalType: "uint8", type: "uint8", indexed: false }
    ],
    name: "Initialized"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "account",
        internalType: "address",
        type: "address",
        indexed: false
      }
    ],
    name: "Paused"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "from", internalType: "address", type: "address", indexed: true },
      { name: "to", internalType: "address", type: "address", indexed: true },
      {
        name: "version",
        internalType: "uint256",
        type: "uint256",
        indexed: true
      },
      {
        name: "opaqueData",
        internalType: "bytes",
        type: "bytes",
        indexed: false
      }
    ],
    name: "TransactionDeposited"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "account",
        internalType: "address",
        type: "address",
        indexed: false
      }
    ],
    name: "Unpaused"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "withdrawalHash",
        internalType: "bytes32",
        type: "bytes32",
        indexed: true
      },
      { name: "success", internalType: "bool", type: "bool", indexed: false }
    ],
    name: "WithdrawalFinalized"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      {
        name: "withdrawalHash",
        internalType: "bytes32",
        type: "bytes32",
        indexed: true
      },
      { name: "from", internalType: "address", type: "address", indexed: true },
      { name: "to", internalType: "address", type: "address", indexed: true }
    ],
    name: "WithdrawalProven"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "GUARDIAN",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "L2_ORACLE",
    outputs: [
      { name: "", internalType: "contract L2OutputOracle", type: "address" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "SYSTEM_CONFIG",
    outputs: [
      { name: "", internalType: "contract SystemConfig", type: "address" }
    ]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      { name: "_to", internalType: "address", type: "address" },
      { name: "_value", internalType: "uint256", type: "uint256" },
      { name: "_gasLimit", internalType: "uint64", type: "uint64" },
      { name: "_isCreation", internalType: "bool", type: "bool" },
      { name: "_data", internalType: "bytes", type: "bytes" }
    ],
    name: "depositTransaction",
    outputs: []
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [],
    name: "donateETH",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "_tx",
        internalType: "struct Types.WithdrawalTransaction",
        type: "tuple",
        components: [
          { name: "nonce", internalType: "uint256", type: "uint256" },
          { name: "sender", internalType: "address", type: "address" },
          { name: "target", internalType: "address", type: "address" },
          { name: "value", internalType: "uint256", type: "uint256" },
          { name: "gasLimit", internalType: "uint256", type: "uint256" },
          { name: "data", internalType: "bytes", type: "bytes" }
        ]
      }
    ],
    name: "finalizeWithdrawalTransaction",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "bytes32", type: "bytes32" }],
    name: "finalizedWithdrawals",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "guardian",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "_l2Oracle",
        internalType: "contract L2OutputOracle",
        type: "address"
      },
      { name: "_guardian", internalType: "address", type: "address" },
      {
        name: "_systemConfig",
        internalType: "contract SystemConfig",
        type: "address"
      },
      { name: "_paused", internalType: "bool", type: "bool" }
    ],
    name: "initialize",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "_l2OutputIndex", internalType: "uint256", type: "uint256" }
    ],
    name: "isOutputFinalized",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "l2Oracle",
    outputs: [
      { name: "", internalType: "contract L2OutputOracle", type: "address" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "l2Sender",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "pure",
    type: "function",
    inputs: [{ name: "_byteCount", internalType: "uint64", type: "uint64" }],
    name: "minimumGasLimit",
    outputs: [{ name: "", internalType: "uint64", type: "uint64" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "params",
    outputs: [
      { name: "prevBaseFee", internalType: "uint128", type: "uint128" },
      { name: "prevBoughtGas", internalType: "uint64", type: "uint64" },
      { name: "prevBlockNum", internalType: "uint64", type: "uint64" }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [],
    name: "pause",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "paused",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "_tx",
        internalType: "struct Types.WithdrawalTransaction",
        type: "tuple",
        components: [
          { name: "nonce", internalType: "uint256", type: "uint256" },
          { name: "sender", internalType: "address", type: "address" },
          { name: "target", internalType: "address", type: "address" },
          { name: "value", internalType: "uint256", type: "uint256" },
          { name: "gasLimit", internalType: "uint256", type: "uint256" },
          { name: "data", internalType: "bytes", type: "bytes" }
        ]
      },
      { name: "_l2OutputIndex", internalType: "uint256", type: "uint256" },
      {
        name: "_outputRootProof",
        internalType: "struct Types.OutputRootProof",
        type: "tuple",
        components: [
          { name: "version", internalType: "bytes32", type: "bytes32" },
          { name: "stateRoot", internalType: "bytes32", type: "bytes32" },
          {
            name: "messagePasserStorageRoot",
            internalType: "bytes32",
            type: "bytes32"
          },
          { name: "latestBlockhash", internalType: "bytes32", type: "bytes32" }
        ]
      },
      { name: "_withdrawalProof", internalType: "bytes[]", type: "bytes[]" }
    ],
    name: "proveWithdrawalTransaction",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "bytes32", type: "bytes32" }],
    name: "provenWithdrawals",
    outputs: [
      { name: "outputRoot", internalType: "bytes32", type: "bytes32" },
      { name: "timestamp", internalType: "uint128", type: "uint128" },
      { name: "l2OutputIndex", internalType: "uint128", type: "uint128" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "systemConfig",
    outputs: [
      { name: "", internalType: "contract SystemConfig", type: "address" }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [],
    name: "unpause",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "version",
    outputs: [{ name: "", internalType: "string", type: "string" }]
  },
  { stateMutability: "payable", type: "receive" }
];

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/estimateDepositTransactionGas.js
async function estimateDepositTransactionGas(client, parameters) {
  const { account, chain = client.chain, gas, maxFeePerGas, maxPriorityFeePerGas, nonce, request: { data = "0x", gas: l2Gas, isCreation = false, mint, to = "0x", value }, targetChain } = parameters;
  const portalAddress = (() => {
    if (parameters.portalAddress)
      return parameters.portalAddress;
    if (chain)
      return targetChain.contracts.portal[chain.id].address;
    return Object.values(targetChain.contracts.portal)[0].address;
  })();
  return estimateContractGas(client, {
    account,
    abi: portalAbi,
    address: portalAddress,
    chain,
    functionName: "depositTransaction",
    args: [
      isCreation ? zeroAddress : to,
      value ?? mint ?? 0n,
      l2Gas,
      isCreation,
      data
    ],
    gas,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    value: mint
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/depositTransaction.js
async function depositTransaction(client, parameters) {
  const { account, chain = client.chain, gas, maxFeePerGas, maxPriorityFeePerGas, nonce, request: { data = "0x", gas: l2Gas, isCreation = false, mint, to = "0x", value }, targetChain } = parameters;
  const portalAddress = (() => {
    if (parameters.portalAddress)
      return parameters.portalAddress;
    if (chain)
      return targetChain.contracts.portal[chain.id].address;
    return Object.values(targetChain.contracts.portal)[0].address;
  })();
  const gas_ = typeof gas !== "number" && gas !== null ? await estimateDepositTransactionGas(client, parameters) : void 0;
  return writeContract(client, {
    account,
    abi: portalAbi,
    address: portalAddress,
    chain,
    functionName: "depositTransaction",
    args: [
      isCreation ? zeroAddress : to,
      value ?? mint ?? 0n,
      l2Gas,
      isCreation,
      data
    ],
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    value: mint,
    gas: gas_
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/estimateL1Fee.js
async function estimateL1Fee(client, args) {
  const { chain = client.chain, gasPriceOracleAddress: gasPriceOracleAddress_ } = args;
  const gasPriceOracleAddress = (() => {
    if (gasPriceOracleAddress_)
      return gasPriceOracleAddress_;
    if (chain)
      return getChainContractAddress({
        chain,
        contract: "gasPriceOracle"
      });
    return contracts.gasPriceOracle.address;
  })();
  const request = await prepareTransactionRequest(client, args);
  assertRequest(request);
  const transaction = serializeTransaction({
    ...request,
    type: "eip1559"
  });
  return readContract(client, {
    abi: gasPriceOracleAbi,
    address: gasPriceOracleAddress,
    functionName: "getL1Fee",
    args: [transaction]
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/estimateContractL1Fee.js
async function estimateContractL1Fee(client, parameters) {
  const { abi, address, args, functionName, ...request } = parameters;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const fee = await estimateL1Fee(client, {
      data,
      to: address,
      ...request
    });
    return fee;
  } catch (error) {
    const account = request.account ? parseAccount(request.account) : void 0;
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/chains/op-stack/estimateContractL1Fee",
      functionName,
      sender: account == null ? void 0 : account.address
    });
  }
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/estimateL1Gas.js
async function estimateL1Gas(client, args) {
  const { chain = client.chain, gasPriceOracleAddress: gasPriceOracleAddress_ } = args;
  const gasPriceOracleAddress = (() => {
    if (gasPriceOracleAddress_)
      return gasPriceOracleAddress_;
    if (chain)
      return getChainContractAddress({
        chain,
        contract: "gasPriceOracle"
      });
    return contracts.gasPriceOracle.address;
  })();
  const request = await prepareTransactionRequest(client, args);
  assertRequest(request);
  const transaction = serializeTransaction({
    ...request,
    type: "eip1559"
  });
  return readContract(client, {
    abi: gasPriceOracleAbi,
    address: gasPriceOracleAddress,
    functionName: "getL1GasUsed",
    args: [transaction]
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/estimateContractL1Gas.js
async function estimateContractL1Gas(client, parameters) {
  const { abi, address, args, functionName, ...request } = parameters;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const gas = await estimateL1Gas(client, {
      data,
      to: address,
      ...request
    });
    return gas;
  } catch (error) {
    const account = request.account ? parseAccount(request.account) : void 0;
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/chains/op-stack/estimateContractL1Gas",
      functionName,
      sender: account == null ? void 0 : account.address
    });
  }
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/estimateTotalFee.js
async function estimateTotalFee(client, args) {
  const request = await prepareTransactionRequest(client, args);
  const [l1Fee, l2Gas, l2GasPrice] = await Promise.all([
    estimateL1Fee(client, request),
    estimateGas(client, request),
    getGasPrice(client)
  ]);
  return l1Fee + l2Gas * l2GasPrice;
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/estimateContractTotalFee.js
async function estimateContractTotalFee(client, parameters) {
  const { abi, address, args, functionName, ...request } = parameters;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const fee = await estimateTotalFee(client, {
      data,
      to: address,
      ...request
    });
    return fee;
  } catch (error) {
    const account = request.account ? parseAccount(request.account) : void 0;
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/chains/op-stack/estimateTotalFee",
      functionName,
      sender: account == null ? void 0 : account.address
    });
  }
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/estimateTotalGas.js
async function estimateTotalGas(client, args) {
  const request = await prepareTransactionRequest(client, args);
  const [l1Gas, l2Gas] = await Promise.all([
    estimateL1Gas(client, request),
    estimateGas(client, request)
  ]);
  return l1Gas + l2Gas;
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/estimateContractTotalGas.js
async function estimateContractTotalGas(client, parameters) {
  const { abi, address, args, functionName, ...request } = parameters;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const gas = await estimateTotalGas(client, {
      data,
      to: address,
      ...request
    });
    return gas;
  } catch (error) {
    const account = request.account ? parseAccount(request.account) : void 0;
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/chains/op-stack/estimateTotalGas",
      functionName,
      sender: account == null ? void 0 : account.address
    });
  }
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/getL1BaseFee.js
async function getL1BaseFee(client, args) {
  const { chain = client.chain, gasPriceOracleAddress: gasPriceOracleAddress_ } = args || {};
  const gasPriceOracleAddress = (() => {
    if (gasPriceOracleAddress_)
      return gasPriceOracleAddress_;
    if (chain)
      return getChainContractAddress({
        chain,
        contract: "gasPriceOracle"
      });
    return contracts.gasPriceOracle.address;
  })();
  return readContract(client, {
    abi: gasPriceOracleAbi,
    address: gasPriceOracleAddress,
    functionName: "l1BaseFee"
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/estimateFinalizeWithdrawalGas.js
async function estimateFinalizeWithdrawalGas(client, parameters) {
  const { account, chain = client.chain, gas, maxFeePerGas, maxPriorityFeePerGas, nonce, targetChain, withdrawal } = parameters;
  const portalAddress = (() => {
    if (parameters.portalAddress)
      return parameters.portalAddress;
    if (chain)
      return targetChain.contracts.portal[chain.id].address;
    return Object.values(targetChain.contracts.portal)[0].address;
  })();
  return estimateContractGas(client, {
    account,
    abi: portalAbi,
    address: portalAddress,
    chain,
    functionName: "finalizeWithdrawalTransaction",
    args: [withdrawal],
    gas,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/finalizeWithdrawal.js
async function finalizeWithdrawal(client, parameters) {
  const { account, chain = client.chain, gas, maxFeePerGas, maxPriorityFeePerGas, nonce, targetChain, withdrawal } = parameters;
  const portalAddress = (() => {
    if (parameters.portalAddress)
      return parameters.portalAddress;
    if (chain)
      return targetChain.contracts.portal[chain.id].address;
    return Object.values(targetChain.contracts.portal)[0].address;
  })();
  const gas_ = typeof gas !== "number" && gas !== null ? await estimateFinalizeWithdrawalGas(client, parameters) : void 0;
  return writeContract(client, {
    account,
    abi: portalAbi,
    address: portalAddress,
    chain,
    functionName: "finalizeWithdrawalTransaction",
    args: [withdrawal],
    gas: gas_,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/getL2Output.js
async function getL2Output(client, parameters) {
  const { chain = client.chain, l2BlockNumber, targetChain } = parameters;
  const l2OutputOracleAddress = (() => {
    if (parameters.l2OutputOracleAddress)
      return parameters.l2OutputOracleAddress;
    if (chain)
      return targetChain.contracts.l2OutputOracle[chain.id].address;
    return Object.values(targetChain.contracts.l2OutputOracle)[0].address;
  })();
  const outputIndex = await readContract(client, {
    address: l2OutputOracleAddress,
    abi: l2OutputOracleAbi,
    functionName: "getL2OutputIndexAfter",
    args: [l2BlockNumber]
  });
  const output = await readContract(client, {
    address: l2OutputOracleAddress,
    abi: l2OutputOracleAbi,
    functionName: "getL2Output",
    args: [outputIndex]
  });
  return { outputIndex, ...output };
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/getTimeToFinalize.js
var buffer = 10;
async function getTimeToFinalize(client, parameters) {
  const { chain = client.chain, withdrawalHash, targetChain } = parameters;
  const l2OutputOracleAddress = (() => {
    if (parameters.l2OutputOracleAddress)
      return parameters.l2OutputOracleAddress;
    if (chain)
      return targetChain.contracts.l2OutputOracle[chain.id].address;
    return Object.values(targetChain.contracts.l2OutputOracle)[0].address;
  })();
  const portalAddress = (() => {
    if (parameters.portalAddress)
      return parameters.portalAddress;
    if (chain)
      return targetChain.contracts.portal[chain.id].address;
    return Object.values(targetChain.contracts.portal)[0].address;
  })();
  const [[_outputRoot, proveTimestamp, _l2OutputIndex], period] = await multicall(client, {
    allowFailure: false,
    contracts: [
      {
        abi: portalAbi,
        address: portalAddress,
        functionName: "provenWithdrawals",
        args: [withdrawalHash]
      },
      {
        abi: l2OutputOracleAbi,
        address: l2OutputOracleAddress,
        functionName: "FINALIZATION_PERIOD_SECONDS"
      }
    ]
  });
  const secondsSinceProven = Date.now() / 1e3 - Number(proveTimestamp);
  const secondsToFinalize = Number(period) - secondsSinceProven;
  const seconds = Math.floor(secondsToFinalize < 0 ? 0 : secondsToFinalize + buffer);
  const timestamp = Date.now() + seconds * 1e3;
  return { period: Number(period), seconds, timestamp };
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/getTimeToNextL2Output.js
async function getTimeToNextL2Output(client, parameters) {
  const { intervalBuffer = 1.1, chain = client.chain, l2BlockNumber, targetChain } = parameters;
  const l2OutputOracleAddress = (() => {
    if (parameters.l2OutputOracleAddress)
      return parameters.l2OutputOracleAddress;
    if (chain)
      return targetChain.contracts.l2OutputOracle[chain.id].address;
    return Object.values(targetChain.contracts.l2OutputOracle)[0].address;
  })();
  const [latestOutputIndex, blockTime, blockInterval] = await multicall(client, {
    allowFailure: false,
    contracts: [
      {
        abi: l2OutputOracleAbi,
        address: l2OutputOracleAddress,
        functionName: "latestOutputIndex"
      },
      {
        abi: l2OutputOracleAbi,
        address: l2OutputOracleAddress,
        functionName: "L2_BLOCK_TIME"
      },
      {
        abi: l2OutputOracleAbi,
        address: l2OutputOracleAddress,
        functionName: "SUBMISSION_INTERVAL"
      }
    ]
  });
  const latestOutput = await readContract(client, {
    abi: l2OutputOracleAbi,
    address: l2OutputOracleAddress,
    functionName: "getL2Output",
    args: [latestOutputIndex]
  });
  const latestOutputTimestamp = Number(latestOutput.timestamp) * 1e3;
  const interval = Number(blockInterval * blockTime);
  const intervalWithBuffer = Math.ceil(interval * intervalBuffer);
  const now = Date.now();
  const seconds = (() => {
    if (now < latestOutputTimestamp)
      return 0;
    if (latestOutput.l2BlockNumber > l2BlockNumber)
      return 0;
    const elapsedBlocks = Number(l2BlockNumber - latestOutput.l2BlockNumber);
    const elapsed = Math.ceil((now - latestOutputTimestamp) / 1e3);
    const secondsToNextOutput = intervalWithBuffer - elapsed % intervalWithBuffer;
    return elapsedBlocks < blockInterval ? secondsToNextOutput : Math.floor(elapsedBlocks / Number(blockInterval)) * intervalWithBuffer + secondsToNextOutput;
  })();
  const timestamp = seconds > 0 ? now + seconds * 1e3 : void 0;
  return { interval, seconds, timestamp };
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/getTimeToProve.js
async function getTimeToProve(client, parameters) {
  const { receipt } = parameters;
  return getTimeToNextL2Output(client, {
    ...parameters,
    l2BlockNumber: receipt.blockNumber
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/errors/withdrawal.js
var ReceiptContainsNoWithdrawalsError = class extends BaseError {
  constructor({ hash }) {
    super(`The provided transaction receipt with hash "${hash}" contains no withdrawals.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ReceiptContainsNoWithdrawalsError"
    });
  }
};

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/utils/extractWithdrawalMessageLogs.js
function extractWithdrawalMessageLogs({ logs }) {
  return parseEventLogs({
    abi: l2ToL1MessagePasserAbi,
    eventName: "MessagePassed",
    logs
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/utils/getWithdrawals.js
function getWithdrawals({ logs }) {
  const extractedLogs = extractWithdrawalMessageLogs({ logs });
  return extractedLogs.map((log) => log.args);
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/getWithdrawalStatus.js
async function getWithdrawalStatus(client, parameters) {
  var _a, _b;
  const { chain = client.chain, receipt, targetChain } = parameters;
  const portalAddress = (() => {
    if (parameters.portalAddress)
      return parameters.portalAddress;
    if (chain)
      return targetChain.contracts.portal[chain.id].address;
    return Object.values(targetChain.contracts.portal)[0].address;
  })();
  const [withdrawal] = getWithdrawals(receipt);
  if (!withdrawal)
    throw new ReceiptContainsNoWithdrawalsError({
      hash: receipt.transactionHash
    });
  const [outputResult, proveResult, finalizedResult, timeToFinalizeResult] = await Promise.allSettled([
    getL2Output(client, {
      ...parameters,
      l2BlockNumber: receipt.blockNumber
    }),
    readContract(client, {
      abi: portalAbi,
      address: portalAddress,
      functionName: "provenWithdrawals",
      args: [withdrawal.withdrawalHash]
    }),
    readContract(client, {
      abi: portalAbi,
      address: portalAddress,
      functionName: "finalizedWithdrawals",
      args: [withdrawal.withdrawalHash]
    }),
    getTimeToFinalize(client, {
      ...parameters,
      withdrawalHash: withdrawal.withdrawalHash
    })
  ]);
  if (outputResult.status === "rejected") {
    const error = outputResult.reason;
    if (error.cause instanceof ContractFunctionRevertedError && ((_b = (_a = error.cause.data) == null ? void 0 : _a.args) == null ? void 0 : _b[0]) === "L2OutputOracle: cannot get output for a block that has not been proposed")
      return "waiting-to-prove";
    throw error;
  }
  if (proveResult.status === "rejected")
    throw proveResult.reason;
  if (finalizedResult.status === "rejected")
    throw finalizedResult.reason;
  if (timeToFinalizeResult.status === "rejected")
    throw timeToFinalizeResult.reason;
  const [_, proveTimestamp] = proveResult.value;
  if (!proveTimestamp)
    return "ready-to-prove";
  const finalized = finalizedResult.value;
  if (finalized)
    return "finalized";
  const { seconds } = timeToFinalizeResult.value;
  return seconds > 0 ? "waiting-to-finalize" : "ready-to-finalize";
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/estimateInitiateWithdrawalGas.js
async function estimateInitiateWithdrawalGas(client, parameters) {
  const { account, chain = client.chain, gas, maxFeePerGas, maxPriorityFeePerGas, nonce, request: { data = "0x", gas: l1Gas, to, value } } = parameters;
  return estimateContractGas(client, {
    account,
    abi: l2ToL1MessagePasserAbi,
    address: contracts.l2ToL1MessagePasser.address,
    chain,
    functionName: "initiateWithdrawal",
    args: [to, l1Gas, data],
    gas,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    value
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/initiateWithdrawal.js
async function initiateWithdrawal(client, parameters) {
  const { account, chain = client.chain, gas, maxFeePerGas, maxPriorityFeePerGas, nonce, request: { data = "0x", gas: l1Gas, to, value } } = parameters;
  const gas_ = typeof gas !== "number" && gas !== null ? await estimateInitiateWithdrawalGas(client, parameters) : void 0;
  return writeContract(client, {
    account,
    abi: l2ToL1MessagePasserAbi,
    address: contracts.l2ToL1MessagePasser.address,
    chain,
    functionName: "initiateWithdrawal",
    args: [to, l1Gas, data],
    gas: gas_,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    value
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/estimateProveWithdrawalGas.js
async function estimateProveWithdrawalGas(client, parameters) {
  const { account, chain = client.chain, gas, l2OutputIndex, maxFeePerGas, maxPriorityFeePerGas, nonce, outputRootProof, targetChain, withdrawalProof, withdrawal } = parameters;
  const portalAddress = (() => {
    if (parameters.portalAddress)
      return parameters.portalAddress;
    if (chain)
      return targetChain.contracts.portal[chain.id].address;
    return Object.values(targetChain.contracts.portal)[0].address;
  })();
  return estimateContractGas(client, {
    account,
    abi: portalAbi,
    address: portalAddress,
    chain,
    functionName: "proveWithdrawalTransaction",
    args: [withdrawal, l2OutputIndex, outputRootProof, withdrawalProof],
    gas,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/proveWithdrawal.js
async function proveWithdrawal(client, parameters) {
  const { account, chain = client.chain, gas, l2OutputIndex, maxFeePerGas, maxPriorityFeePerGas, nonce, outputRootProof, targetChain, withdrawalProof, withdrawal } = parameters;
  const portalAddress = (() => {
    if (parameters.portalAddress)
      return parameters.portalAddress;
    if (chain)
      return targetChain.contracts.portal[chain.id].address;
    return Object.values(targetChain.contracts.portal)[0].address;
  })();
  const gas_ = typeof gas !== "number" && gas !== null ? await estimateProveWithdrawalGas(client, parameters) : gas ?? void 0;
  return writeContract(client, {
    account,
    abi: portalAbi,
    address: portalAddress,
    chain,
    functionName: "proveWithdrawalTransaction",
    args: [withdrawal, l2OutputIndex, outputRootProof, withdrawalProof],
    gas: gas_,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/waitForNextL2Output.js
async function waitForNextL2Output(client, parameters) {
  const { pollingInterval = client.pollingInterval } = parameters;
  const { seconds } = await getTimeToNextL2Output(client, parameters);
  return new Promise((resolve, reject) => {
    poll(async ({ unpoll }) => {
      try {
        const output = await getL2Output(client, parameters);
        unpoll();
        resolve(output);
      } catch (e) {
        const error = e;
        if (!(error.cause instanceof ContractFunctionRevertedError)) {
          unpoll();
          reject(e);
        }
      }
    }, {
      interval: pollingInterval,
      initialWaitTime: async () => seconds * 1e3
    });
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/waitToFinalize.js
async function waitToFinalize(client, parameters) {
  const { seconds } = await getTimeToFinalize(client, parameters);
  await wait(seconds * 1e3);
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/actions/waitToProve.js
async function waitToProve(client, parameters) {
  const { receipt } = parameters;
  const [withdrawal] = getWithdrawals(receipt);
  if (!withdrawal)
    throw new ReceiptContainsNoWithdrawalsError({
      hash: receipt.transactionHash
    });
  const output = await waitForNextL2Output(client, {
    ...parameters,
    l2BlockNumber: receipt.blockNumber
  });
  return { output, withdrawal };
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/decorators/publicL1.js
function publicActionsL1() {
  return (client) => {
    return {
      buildInitiateWithdrawal: (args) => buildInitiateWithdrawal(client, args),
      estimateDepositTransactionGas: (args) => estimateDepositTransactionGas(client, args),
      estimateFinalizeWithdrawalGas: (args) => estimateFinalizeWithdrawalGas(client, args),
      estimateProveWithdrawalGas: (args) => estimateProveWithdrawalGas(client, args),
      getL2Output: (args) => getL2Output(client, args),
      getTimeToFinalize: (args) => getTimeToFinalize(client, args),
      getTimeToNextL2Output: (args) => getTimeToNextL2Output(client, args),
      getTimeToProve: (args) => getTimeToProve(client, args),
      getWithdrawalStatus: (args) => getWithdrawalStatus(client, args),
      waitForNextL2Output: (args) => waitForNextL2Output(client, args),
      waitToFinalize: (args) => waitToFinalize(client, args),
      waitToProve: (args) => waitToProve(client, args)
    };
  };
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/decorators/publicL2.js
function publicActionsL2() {
  return (client) => {
    return {
      buildDepositTransaction: (args) => buildDepositTransaction(client, args),
      buildProveWithdrawal: (args) => buildProveWithdrawal(client, args),
      estimateContractL1Fee: (args) => estimateContractL1Fee(client, args),
      estimateContractL1Gas: (args) => estimateContractL1Gas(client, args),
      estimateContractTotalFee: (args) => estimateContractTotalFee(client, args),
      estimateContractTotalGas: (args) => estimateContractTotalGas(client, args),
      estimateInitiateWithdrawalGas: (args) => estimateInitiateWithdrawalGas(client, args),
      estimateL1Fee: (args) => estimateL1Fee(client, args),
      getL1BaseFee: (args) => getL1BaseFee(client, args),
      estimateL1Gas: (args) => estimateL1Gas(client, args),
      estimateTotalFee: (args) => estimateTotalFee(client, args),
      estimateTotalGas: (args) => estimateTotalGas(client, args)
    };
  };
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/decorators/walletL1.js
function walletActionsL1() {
  return (client) => {
    return {
      depositTransaction: (args) => depositTransaction(client, args),
      finalizeWithdrawal: (args) => finalizeWithdrawal(client, args),
      proveWithdrawal: (args) => proveWithdrawal(client, args)
    };
  };
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/decorators/walletL2.js
function walletActionsL2() {
  return (client) => {
    return {
      initiateWithdrawal: (args) => initiateWithdrawal(client, args)
    };
  };
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/parsers.js
function parseTransaction2(serializedTransaction) {
  const serializedType = sliceHex(serializedTransaction, 0, 1);
  if (serializedType === "0x7e")
    return parseTransactionDeposit(serializedTransaction);
  return parseTransaction(serializedTransaction);
}
function parseTransactionDeposit(serializedTransaction) {
  const transactionArray = toTransactionArray(serializedTransaction);
  const [sourceHash, from, to, mint, value, gas, isSystemTx, data] = transactionArray;
  if (transactionArray.length !== 8 || !isHex(sourceHash) || !isHex(from))
    throw new InvalidSerializedTransactionError({
      attributes: {
        sourceHash,
        from,
        gas,
        to,
        mint,
        value,
        isSystemTx,
        data
      },
      serializedTransaction,
      type: "deposit"
    });
  const transaction = {
    sourceHash,
    from,
    type: "deposit"
  };
  if (isHex(gas) && gas !== "0x")
    transaction.gas = hexToBigInt(gas);
  if (isHex(to) && to !== "0x")
    transaction.to = to;
  if (isHex(mint) && mint !== "0x")
    transaction.mint = hexToBigInt(mint);
  if (isHex(value) && value !== "0x")
    transaction.value = hexToBigInt(value);
  if (isHex(isSystemTx) && isSystemTx !== "0x")
    transaction.isSystemTx = hexToBool(isSystemTx);
  if (isHex(data) && data !== "0x")
    transaction.data = data;
  assertTransactionDeposit(transaction);
  return transaction;
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/utils/extractTransactionDepositedLogs.js
function extractTransactionDepositedLogs({ logs }) {
  return parseEventLogs({
    abi: portalAbi,
    eventName: "TransactionDeposited",
    logs
  });
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/utils/opaqueDataToDepositData.js
function opaqueDataToDepositData(opaqueData) {
  let offset = 0;
  const mint = slice(opaqueData, offset, offset + 32);
  offset += 32;
  const value = slice(opaqueData, offset, offset + 32);
  offset += 32;
  const gas = slice(opaqueData, offset, offset + 8);
  offset += 8;
  const isCreation = BigInt(slice(opaqueData, offset, offset + 1)) === 1n;
  offset += 1;
  const data = offset > size(opaqueData) - 1 ? "0x" : slice(opaqueData, offset, opaqueData.length);
  return {
    mint: hexToBigInt(mint),
    value: hexToBigInt(value),
    gas: hexToBigInt(gas),
    isCreation,
    data
  };
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/utils/getSourceHash.js
var sourceHashDomainMap = {
  userDeposit: 0,
  l1InfoDeposit: 1
};
function getSourceHash({ domain, l1LogIndex, l1BlockHash, sequenceNumber }) {
  const marker = toHex(l1LogIndex || sequenceNumber);
  const input = concat([l1BlockHash, pad(marker, { size: 32 })]);
  const depositIdHash = keccak256(input);
  const domainHex = toHex(sourceHashDomainMap[domain]);
  const domainInput = concat([pad(domainHex, { size: 32 }), depositIdHash]);
  return keccak256(domainInput);
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/utils/getL2TransactionHash.js
function getL2TransactionHash({ log }) {
  const sourceHash = getSourceHash({
    domain: "userDeposit",
    l1BlockHash: log.blockHash,
    l1LogIndex: log.logIndex
  });
  const { data, gas, isCreation, mint, value } = opaqueDataToDepositData(log.args.opaqueData);
  return keccak256(serializeTransaction2({
    from: log.args.from,
    to: isCreation ? void 0 : log.args.to,
    sourceHash,
    data,
    gas,
    isSystemTx: false,
    mint,
    type: "deposit",
    value
  }));
}

// node_modules/.pnpm/viem@2.8.5_typescript@5.4.2/node_modules/viem/_esm/chains/opStack/utils/getL2TransactionHashes.js
function getL2TransactionHashes({ logs }) {
  const extractedLogs = extractTransactionDepositedLogs({ logs });
  return extractedLogs.map((log) => getL2TransactionHash({ log }));
}
export {
  ancient8,
  ancient8Sepolia,
  base,
  baseGoerli,
  baseSepolia,
  buildDepositTransaction,
  buildInitiateWithdrawal,
  buildProveWithdrawal,
  chainConfig,
  depositTransaction,
  estimateContractL1Fee,
  estimateContractL1Gas,
  estimateContractTotalFee,
  estimateContractTotalGas,
  estimateL1Fee,
  estimateL1Gas,
  estimateTotalFee,
  estimateTotalGas,
  extractTransactionDepositedLogs,
  extractWithdrawalMessageLogs,
  finalizeWithdrawal,
  fraxtal,
  fraxtalTestnet,
  getL1BaseFee,
  getL2Output,
  getL2TransactionHash,
  getL2TransactionHashes,
  getSourceHash,
  getTimeToFinalize,
  getTimeToNextL2Output,
  getTimeToProve,
  getWithdrawalHashStorageSlot,
  getWithdrawalStatus,
  getWithdrawals,
  initiateWithdrawal,
  opaqueDataToDepositData,
  optimism,
  optimismGoerli,
  optimismSepolia,
  parseTransaction2 as parseTransaction,
  pgn,
  pgnTestnet,
  proveWithdrawal,
  publicActionsL1,
  publicActionsL2,
  serializeTransaction2 as serializeTransaction,
  serializers,
  waitForNextL2Output,
  waitToFinalize,
  waitToProve,
  walletActionsL1,
  walletActionsL2,
  zora,
  zoraSepolia,
  zoraTestnet
};
//# sourceMappingURL=viem_op-stack.js.map
